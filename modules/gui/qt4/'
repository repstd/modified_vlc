/*****************************************************************************
 * qt4.cpp : QT4 interface
 * gg
 ****************************************************************************
 * Copyright © 2006-2009 the VideoLAN team
 * $Id: 7ff935fc934d7a3e35201c34cbae8ef6a7a2614d $
 *
 * Authors: Clément Stenac <zorglub@videolan.org>
 *          Jean-Baptiste Kempf <jb@videolan.org>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
 *****************************************************************************/

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif

#include <QApplication>
#include <QDate>
#include <QMutex>

#include "qt4.hpp"

#include "input_manager.hpp"    /* THEMIM destruction */
#include "dialogs_provider.hpp" /* THEDP creation */
#include "main_interface.hpp"   /* MainInterface creation */
#include "dialogs/help.hpp"     /* Launch Update */
#include "recents.hpp"          /* Recents Item destruction */
#include "util/qvlcapp.hpp"     /* QVLCApplication definition */
#include "components/playlist/playlist_model.hpp" /* for ~PLModel() */
#include <vlc_aout_intf.h>
#include "remoteControlServer.hpp"
#include "rclog.h"
#include "vlc_charset.h"
#ifdef Q_WS_X11
#include <vlc_xlib.h>
#endif

#include "../../../share/icons/32x32/vlc.xpm"
#include "../../../share/icons/32x32/vlc-xmas.xpm"
#include <vlc_plugin.h>
#include <vlc_vout_window.h>
#include <vlc_input.h>
#include <locale>
#include <iostream>
#include <string>
#include <sstream>
using namespace std;
#define MSG_SIZE 50
#ifdef WIN32 /* For static builds */
#include <QtPlugin>
    Q_IMPORT_PLUGIN(qjpeg)
Q_IMPORT_PLUGIN(qtaccessiblewidgets)
#endif

    /*****************************************************************************
     * Local prototypes.
     *****************************************************************************/
    static int  OpenIntf     ( vlc_object_t * );
    static int  OpenDialogs  ( vlc_object_t * );
    static int  Open         ( vlc_object_t *, bool );
    static void Close        ( vlc_object_t * );
    static int  WindowOpen   ( vout_window_t *, const vout_window_cfg_t * );
    static void WindowClose  ( vout_window_t * );
    static void *Thread      ( void * );
    static void ShowDialog   ( intf_thread_t *, int, int, intf_dialog_args_t * );

    /*****************************************************************************
     * Module descriptor
     *****************************************************************************/
#define ADVANCED_PREFS_TEXT N_( "Show advanced preferences over simple ones" )
#define ADVANCED_PREFS_LONGTEXT N_( "Show advanced preferences and not simple "\
        "preferences when opening the preferences "\
        "dialog." )

#define SYSTRAY_TEXT N_( "Systray icon" )
#define SYSTRAY_LONGTEXT N_( "Show an icon in the systray " \
        "allowing you to control VLC media player " \
        "for basic actions." )

#define MINIMIZED_TEXT N_( "Start VLC with only a systray icon" )
#define MINIMIZED_LONGTEXT N_( "VLC will start with just an icon in " \
        "your taskbar" )

#define KEEPSIZE_TEXT N_( "Resize interface to the native video size" )
#define KEEPSIZE_LONGTEXT N_( "You have two choices:\n" \
        " - The interface will resize to the native video size\n" \
        " - The video will fit to the interface size\n " \
        "By default, interface resize to the native video size." )

#define TITLE_TEXT N_( "Show playing item name in window title" )
#define TITLE_LONGTEXT N_( "Show the name of the song or video in the " \
        "controller window title." )

#define NOTIFICATION_TEXT N_( "Show notification popup on track change" )
#define NOTIFICATION_LONGTEXT N_( \
        "Show a notification popup with the artist and track name when " \
        "the current playlist item changes, when VLC is minimized or hidden." )

#define ADVANCED_OPTIONS_TEXT N_( "Advanced options" )
#define ADVANCED_OPTIONS_LONGTEXT N_( "Show all the advanced options " \
        "in the dialogs." )

#define OPACITY_TEXT N_( "Windows opacity between 0.1 and 1" )
#define OPACITY_LONGTEXT N_( "Sets the windows opacity between 0.1 and 1 " \
        "for main interface, playlist and extended panel."\
        " This option only works with Windows and " \
        "X11 with composite extensions." )

#define OPACITY_FS_TEXT N_( "Fullscreen controller opacity between 0.1 and 1" )
#define OPACITY_FS_LONGTEXT N_( "Sets the fullscreen controller opacity between 0.1 and 1 " \
        "for main interface, playlist and extended panel."\
        " This option only works with Windows and " \
        "X11 with composite extensions." )


#define ERROR_TEXT N_( "Show unimportant error and warnings dialogs" )

#define UPDATER_TEXT N_( "Activate the updates availability notification" )
#define UPDATER_LONGTEXT N_( "Activate the automatic notification of new " \
        "versions of the software. It runs once every " \
        "two weeks." )
#define UPDATER_DAYS_TEXT N_("Number of days between two update checks")

#define SAVEVOL_TEXT N_( "Automatically save the volume on exit" )

#define PRIVACY_TEXT N_( "Ask for network policy at start" )

#define RECENTPLAY_TEXT N_( "Save the recently played items in the menu" )

#define RECENTPLAY_FILTER_TEXT N_( "List of words separated by | to filter" )
#define RECENTPLAY_FILTER_LONGTEXT N_( "Regular expression used to filter " \
        "the recent items played in the player" )

#define SLIDERCOL_TEXT N_( "Define the colors of the volume slider " )
#define SLIDERCOL_LONGTEXT N_( "Define the colors of the volume slider\n" \
        "By specifying the 12 numbers separated by a ';'\n" \
        "Default is '255;255;255;20;226;20;255;176;15;235;30;20'\n" \
        "An alternative can be '30;30;50;40;40;100;50;50;160;150;150;255' ")

#define QT_MODE_TEXT N_( "Selection of the starting mode and look " )
#define QT_MODE_LONGTEXT N_( "Start VLC with:\n" \
        " - normal mode\n"  \
        " - a zone always present to show information " \
        "as lyrics, album arts...\n" \
        " - minimal mode with limited controls" )

#define QT_FULLSCREEN_TEXT N_( "Show a controller in fullscreen mode" )
#define QT_NATIVEOPEN_TEXT N_( "Embed the file browser in open dialog" )

#define FULLSCREEN_NUMBER_TEXT N_( "Define which screen fullscreen goes" )
#define FULLSCREEN_NUMBER_LONGTEXT N_( "Screennumber of fullscreen, instead of " \
        "same screen where interface is" )

#define QT_AUTOLOAD_EXTENSIONS_TEXT N_( "Load extensions on startup" )
#define QT_AUTOLOAD_EXTENSIONS_LONGTEXT N_( "Automatically load the "\
        "extensions module on startup" )

#define QT_MINIMAL_MODE_TEXT N_("Start in minimal view (without menus)" )

#define QT_BGCONE_TEXT N_( "Display background cone or art" )
#define QT_BGCONE_LONGTEXT N_( "Display background cone or current album art " \
        "when not playing. " \
        "Can be disabled to prevent burning screen." )
#define QT_BGCONE_EXPANDS_TEXT N_( "Expanding background cone or art." )
#define QT_BGCONE_EXPANDS_LONGTEXT N_( "Background art fits window's size" )

#define QT_DISABLE_VOLUME_KEYS_TEXT N_( "Ignore keyboard volume buttons." )
#define QT_DISABLE_VOLUME_KEYS_LONGTEXT N_(                                             \
        "With this option checked, the volume up, volume down and mute buttons on your "    \
        "keyboard will always change your system volume. With this option unchecked, the "  \
        "volume buttons will change VLC's volume when VLC is selected and change the "      \
        "system volume when VLC is not selected." )

#define QT_PAUSE_MINIMIZED_TEXT N_( "Pause the video playback when minimized" )
#define QT_PAUSE_MINIMIZED_LONGTEXT N_( \
        "With this option enabled, the playback will be automatically paused when minimizing the window." )

#define ICONCHANGE_TEXT N_( "Allow automatic icon changes")
#define ICONCHANGE_LONGTEXT N_( \
        "This option allows the interface to change its icon on various occasions.")

    /**********************************************************************/
vlc_module_begin ()
    set_shortname( "Qt" )
    set_description( N_("Qt interface") )
    set_category( CAT_INTERFACE )
set_subcategory( SUBCAT_INTERFACE_MAIN )
    set_capability( "interface", 151 )
set_callbacks( OpenIntf, Close )

    add_shortcut("qt")

    add_bool( "qt-minimal-view", false, QT_MINIMAL_MODE_TEXT,
            QT_MINIMAL_MODE_TEXT, false );

add_bool( "qt-system-tray",
#ifdef HAVE_MAEMO
        false,
#else
        true,
#endif
        SYSTRAY_TEXT, SYSTRAY_LONGTEXT, false)
add_bool( "qt-notification", true, NOTIFICATION_TEXT,
        NOTIFICATION_LONGTEXT, false )
add_bool( "qt-start-minimized", false, MINIMIZED_TEXT,
        MINIMIZED_LONGTEXT, true)
add_bool( "qt-pause-minimized", false, QT_PAUSE_MINIMIZED_TEXT,
        QT_PAUSE_MINIMIZED_LONGTEXT, false )

add_float_with_range( "qt-opacity", 1., 0.1, 1., OPACITY_TEXT,
        OPACITY_LONGTEXT, false )
add_float_with_range( "qt-fs-opacity", 0.8, 0.1, 1., OPACITY_FS_TEXT,
        OPACITY_FS_LONGTEXT, false )

add_bool( "qt-video-autoresize", true, KEEPSIZE_TEXT,
        KEEPSIZE_LONGTEXT, false )
add_bool( "qt-name-in-title", true, TITLE_TEXT,
        TITLE_LONGTEXT, false )
add_bool( "qt-fs-controller", true, QT_FULLSCREEN_TEXT,
        QT_FULLSCREEN_TEXT, false )

add_bool( "qt-recentplay", true, RECENTPLAY_TEXT,
        RECENTPLAY_TEXT, false )
add_string( "qt-recentplay-filter", "",
        RECENTPLAY_FILTER_TEXT, RECENTPLAY_FILTER_LONGTEXT, false )

#ifdef UPDATE_CHECK
add_bool( "qt-updates-notif", true, UPDATER_TEXT,
        UPDATER_LONGTEXT, false )
add_integer_with_range( "qt-updates-days", 3, 0, 180,
        UPDATER_DAYS_TEXT, UPDATER_DAYS_TEXT, false )
#endif

add_bool( "qt-autosave-volume", true, SAVEVOL_TEXT,
        SAVEVOL_TEXT, true )
#ifdef WIN32
add_bool( "qt-disable-volume-keys"             /* name */,
        true                                 /* default value */,
        QT_DISABLE_VOLUME_KEYS_TEXT          /* text */,
        QT_DISABLE_VOLUME_KEYS_LONGTEXT      /* longtext */,
        false                                /* advanced mode only */)
#endif

add_bool( "qt-embedded-open", false, QT_NATIVEOPEN_TEXT,
        QT_NATIVEOPEN_TEXT, false )


add_bool( "qt-advanced-pref", false, ADVANCED_PREFS_TEXT,
        ADVANCED_PREFS_LONGTEXT, false )
add_bool( "qt-error-dialogs", true, ERROR_TEXT,
        ERROR_TEXT, false )

add_string( "qt-slider-colours", "153;210;153;20;210;20;255;199;15;245;39;29",
        SLIDERCOL_TEXT, SLIDERCOL_LONGTEXT, false )

add_bool( "qt-privacy-ask", true, PRIVACY_TEXT, PRIVACY_TEXT,
        false )
change_private ()

    add_integer( "qt-fullscreen-screennumber", -1, FULLSCREEN_NUMBER_TEXT,
            FULLSCREEN_NUMBER_LONGTEXT, false );

add_bool( "qt-autoload-extensions", true,
        QT_AUTOLOAD_EXTENSIONS_TEXT, QT_AUTOLOAD_EXTENSIONS_LONGTEXT,
        false )

add_bool( "qt-bgcone", true, QT_BGCONE_TEXT, QT_BGCONE_LONGTEXT, true )
add_bool( "qt-bgcone-expands", false, QT_BGCONE_EXPANDS_TEXT,
        QT_BGCONE_EXPANDS_LONGTEXT, true )

add_bool( "qt-icon-change", true, ICONCHANGE_TEXT, ICONCHANGE_LONGTEXT, true )

add_obsolete_bool( "qt-blingbling" )      /* Suppressed since 1.0.0 */
add_obsolete_integer( "qt-display-mode" ) /* Suppressed since 1.1.0 */

add_obsolete_bool( "qt-adv-options" )     /* Since 2.0.0 */
add_obsolete_bool( "qt-volume-complete" ) /* Since 2.0.0 */
add_obsolete_integer( "qt-startvolume" )  /* Since 2.0.0 */

cannot_unload_broken_library()

add_submodule ()
    set_description( "Dialogs provider" )
    set_capability( "dialogs provider", 51 )

set_callbacks( OpenDialogs, Close )

#if defined(Q_WS_X11) || defined(Q_WS_WIN) || defined(Q_WS_MAC)  || defined(Q_WS_PM)
add_submodule ()
#if defined(Q_WS_X11)
    set_capability( "vout window xid", 0 )
#elif defined(Q_WS_WIN) || defined(Q_WS_PM)
    set_capability( "vout window hwnd", 0 )
#elif defined(Q_WS_MAC)
    set_capability( "vout window nsobject", 0 )
#endif
set_callbacks( WindowOpen, WindowClose )
#endif

vlc_module_end ()

    /*****************************************/

    /* Ugly, but the Qt4 interface assumes single instance anyway */
    static vlc_sem_t ready;
    static QMutex lock;
    static bool busy = false;
    static bool active = false;

    /*****************************************************************************
     * Module callbacks
     *****************************************************************************/
    //modified by yulw,socket server for yingshitong
    static RCServer* pRemoteControl=NULL;
#ifdef Q_WS_MAC
    /* Used to abort the app.exec() on OSX after libvlc_Quit is called */
#include "../../../lib/libvlc_internal.h" /* libvlc_SetExitHandler */
static void Abort( void *obj )
{
    QVLCApp::triggerQuit();
}
#endif
struct remoteControl
{
    int i_query;
    va_list argv;

};
#define ENCODE_MSG(msg,result)\
    if (result == VLC_SUCCESS)\
        sprintf(msg, "%s", "success"); \
    else \
        sprintf(msg, "%s", "failed");

#define ENCODE_MSG_WITH_RETURN(msg,format,result...) \
    sprintf(msg, format, result);

typedef struct _rc_value_t
{

    bool            b_bool;
    double          f_float;
    char *          psz_string;
} rc_value_t;

wstring widen( const string& str )
{
    wostringstream wstm;
    wstm.imbue(std::locale("en_US.UTF-8"));
    const ctype<wchar_t>& ctfacet = use_facet< ctype<wchar_t> >( wstm.getloc() ) ;
    for( size_t i=0 ; i<str.size() ; ++i )
        wstm << ctfacet.widen( str[i] ) ;
    return wstm.str() ;
}

string narrow( const wstring& str )
{
    ostringstream stm ;
    stm.imbue(std::locale("en_US"));
    const ctype<char>& ctfacet =
        use_facet< ctype<char> >( stm.getloc() ) ;
    for( size_t i=0 ; i<str.size() ; ++i )
        stm << ctfacet.narrow( str[i], 0 ) ;
    return stm.str() ;
}
static input_item_t *parse_MRL(const char *mrl)
{
#define SKIPSPACE( p ) { while( *p == ' ' || *p == '\t' ) p++; }
#define SKIPTRAILINGSPACE( p, d ) \
    { char *e = d; while (e > p && (*(e - 1) == ' ' || *(e - 1) == '\t')){ e--; *e = 0; } }

    input_item_t *p_item = NULL;
    char *psz_item = NULL, *psz_item_mrl = NULL, *psz_orig, *psz_mrl;
    char **ppsz_options = NULL;
    int i, i_options = 0;

    if (!mrl) return 0;

    psz_mrl = psz_orig = strdup(mrl);
    if (!psz_mrl)
        return NULL;
    while (*psz_mrl)
    {
        SKIPSPACE(psz_mrl);
        psz_item = psz_mrl;

        for (; *psz_mrl; psz_mrl++)
        {
            if ((*psz_mrl == ' ' || *psz_mrl == '\t') && psz_mrl[1] == ':')
            {
                /* We have a complete item */
                break;
            }
            if ((*psz_mrl == ' ' || *psz_mrl == '\t') &&
                    (psz_mrl[1] == '"' || psz_mrl[1] == '\'') && psz_mrl[2] == ':')
            {
                /* We have a complete item */
                break;
            }
        }

        if (*psz_mrl) { *psz_mrl = 0; psz_mrl++; }
        SKIPTRAILINGSPACE(psz_item, psz_item + strlen(psz_item));

        /* Remove '"' and '\'' if necessary */
        if (*psz_item == '"' && psz_item[strlen(psz_item) - 1] == '"')
        {
            psz_item++; psz_item[strlen(psz_item) - 1] = 0;
        }
        if (*psz_item == '\'' && psz_item[strlen(psz_item) - 1] == '\'')
        {
            psz_item++; psz_item[strlen(psz_item) - 1] = 0;
        }

        if (!psz_item_mrl)
        {
            /*
               if (strstr(psz_item, "://") != NULL)
               psz_item_mrl = strdup(psz_item);
               else
               psz_item_mrl = vlc_path2uri(psz_item, NULL);
               */
            psz_item_mrl = make_URI( psz_item, NULL );
            if (psz_item_mrl == NULL)
            {
                free(psz_orig);
                return NULL;
            }
        }
        else if (*psz_item)
        {
            i_options++;
            ppsz_options = (char **)xrealloc(ppsz_options, i_options * sizeof(char *));         // sunqueen modify
            ppsz_options[i_options - 1] = &psz_item[1];
        }

        if (*psz_mrl) SKIPSPACE(psz_mrl);
    }

    /* Now create a playlist item */
    if (psz_item_mrl)
    {
        p_item = input_item_New(psz_item_mrl, NULL);
        for (i = 0; i < i_options; i++)
        {
            input_item_AddOption(p_item, ppsz_options[i], VLC_INPUT_OPTION_TRUSTED);
        }
        free(psz_item_mrl);
    }

    if (i_options) free(ppsz_options);
    free(psz_orig);

    return p_item;
}
const char* getTrack(const char* psz_cmd) {
    if (strstr(psz_cmd, "ATrack")!=NULL) {
        return "audio-es";
    }
    else if (strstr(psz_cmd, "VTrack")!=NULL) {
        return "video-es";
    }
    else if(strstr(psz_cmd,"STrack")!=NULL){
        return "spu-es";
    }
    else
        return "Error";
}
const char* getAudioConf(const char* psz_cmd) {
    if (strstr(psz_cmd, "AudioDevice")!=NULL) {
        return  "audio-device";
    }
    else if (strstr(psz_cmd, "AudioChannels")!=NULL) {
        return "audio-channels";
    }
    else
        return "Error";
}
/*
   static void print_playlist( intf_thread_t *p_intf, playlist_item_t *p_item, int i_level )
   {
   int i;
   char psz_buffer[MSTRTIME_MAX_SIZE];
   for( i = 0; i< p_item->i_children; i++ )
   {
   if( p_item->pp_children[i]->p_input->i_duration != -1 )
   {
   secstotimestr( psz_buffer, p_item->pp_children[i]->p_input->i_duration / 1000000 );
   msg_rc( "|%*s- %s (%s)", 2 * i_level, "", p_item->pp_children[i]->p_input->psz_name, psz_buffer );
   }
   else
   msg_rc( "|%*s- %s", 2 * i_level, "", p_item->pp_children[i]->p_input->psz_name );

   if( p_item->pp_children[i]->i_children >= 0 )
   print_playlist( p_intf, p_item->pp_children[i], i_level + 1 );
   }
   }
   */
const char* getTrackTextValueByIndex(const vlc_value_t& val,const vlc_value_t& text,int index) {
    for(int i=0;i<val.p_list->i_count;i++) {
        if(index==val.p_list->p_values[i].i_int) {
            return text.p_list->p_values[i].psz_string;
        }
    }
    return "NotFound";
}
const char* getTotalTrackList(const vlc_value_t&val,const vlc_value_t& text) {
    char result[MAX_SIZE];
    memset(result,0,MAX_SIZE);
    char* p=result;
    int len;
    for(int i=0;i<val.p_list->i_count;i++) {
        *(p++)='[';
        len=strlen(text.p_list->p_values[i].psz_string);
        memcpy(p,text.p_list->p_values[i].psz_string,len);
        p+=len;
        *(p++)=']';
    }
    *(p)='\0';
    string total=result;
    logger::inst()->log(total.c_str());
    return total.c_str();
}
/*
   const char* getTotalPlayList(intf_thread_t *p_intf, playlist_item_t *p_item, int i_level ){

   }
   */
static int AudioConfig(intf_thread_t* p_intf, input_thread_t *p_input, char const *psz_cmd,rc_value_t newval, char*p_data )
{
    const char * psz_variable;
    vlc_value_t val_name;
    int i_error;

    if( !p_input ) {
        i_error = VLC_ENOOBJ;
        ENCODE_MSG(p_data,i_error);
        return i_error;
    }
    int state = var_GetInteger( p_input, "state" );
    if( state == PAUSE_S )
    {
        //msg_rc( "%s", _("Type 'menu select' or 'pause' to continue.") );
        i_error = VLC_EGENERIC;
        ENCODE_MSG(p_data,i_error);
        return i_error;
    }

    vlc_object_t * p_aout = (vlc_object_t *)input_GetAout( p_input );
    vlc_object_release( p_input );
    if ( p_aout == NULL ) {
        i_error = VLC_ENOOBJ;
        ENCODE_MSG(p_data,i_error);
        return i_error;
    }
    psz_variable=getAudioConf(psz_cmd);
    /* Get the descriptive name of the variable */
    var_Change( p_aout, psz_variable, VLC_VAR_GETTEXT, &val_name, NULL );
    if( !val_name.psz_string ) 
        val_name.psz_string = strdup(psz_variable);
    vlc_value_t val, text;
    if(
            !strcmp(psz_cmd,"getAudioDevice")||
            !strcmp(psz_cmd,"getAudioChannels")||
            !strcmp(psz_cmd,"getAudioDeviceText")||
            !strcmp(psz_cmd,"getAudioChannelsText")||
            !strcmp(psz_cmd,"getAllAudioDevice")|| 
            !strcmp(psz_cmd,"getAllAudioChannels")
      ) 
    {
        int i, i_value;
        if ( var_Get( p_aout, psz_variable, &val ) < 0 ) {
            vlc_object_release( p_aout );
            free( val_name.psz_string );
            i_error = VLC_EGENERIC;
            ENCODE_MSG(p_data,i_error);
            return i_error;
        }
        i_value = val.i_int;
        if ( var_Change( p_aout, psz_variable,
                    VLC_VAR_GETLIST, &val, &text ) < 0 ) {
            vlc_object_release( p_aout );
            free( val_name.psz_string );
            i_error = VLC_EGENERIC;
            ENCODE_MSG(p_data,i_error);
            return i_error;
        }
        //if ( !*newval.psz_string)
        if (strstr(psz_cmd,"All")!=NULL) {
            //GetAllLists
            /* Retrieve all registered ***. */
            const char* totalTrackList=getTotalTrackList(val,text);
            ENCODE_MSG_WITH_RETURN(p_data,"%s",totalTrackList);
            i_error = VLC_SUCCESS;
        }
        else {
            if(strstr(psz_cmd,"Text")!=NULL) {
                ENCODE_MSG_WITH_RETURN(p_data, "%s", getTrackTextValueByIndex(val,text,i_value));
            }
            else
                ENCODE_MSG_WITH_RETURN(p_data, "%d", i_value);
        }
        var_FreeList( &val, &text );
    } 
    else if( !strcmp(psz_cmd,"setAudioDevice")||
            !strcmp(psz_cmd,"setAudioChannels")) 
    {
        //Set
        vlc_value_t val;
        val.i_int = atoi( newval.psz_string );
        i_error = var_Set( p_aout, psz_variable, val );
        ENCODE_MSG(p_data,i_error);
    }
    free( val_name.psz_string );
    vlc_object_release( p_aout );
    return i_error;
}

static int Input(intf_thread_t* p_intf, input_thread_t *p_input, char const *psz_cmd, rc_value_t newval, char* p_data) {

    int result = VLC_EGENERIC;
    playlist_t *p_playlist = pl_Get(p_intf);
    vlc_value_t val = { 0 };
    char buf[30];


    if (!p_input || p_input->b_dead)
    {

        if (!strcmp(psz_cmd, "setAdd")||!strcmp(psz_cmd, "setOpen")&&newval.psz_string&&*newval.psz_string)
        {

            input_item_t *p_item = parse_MRL(newval.psz_string);

            if (p_item)
            {
                result = playlist_AddInput(p_playlist, p_item,
                        PLAYLIST_GO | PLAYLIST_APPEND, PLAYLIST_END, true,
                        pl_Unlocked);
                vlc_gc_decref(p_item);
            }


            ENCODE_MSG(p_data, result);

        }
        else
        {

            ENCODE_MSG_WITH_RETURN(p_data, "%s","Add or ReOpen a File First");

        }

        return VLC_ENOOBJ;

    }
    else
    {

        int state = var_GetInteger(p_input, "state");
        /*
           if ((state != PLAYING_S) &&strcmp(psz_cmd, "play")&&strcmp(psz_cmd, "frame")&&strncmp(psz_cmd, "get",3)) {
           ENCODE_MSG_WITH_RETURN(p_data, "%s", "Only 'Set' or 'Play' operation is allowed.");
           }
           else 
           */
        if (!strcmp(psz_cmd, "getState"))
        {

            switch (state)
            {
                case INIT_S:

                    ENCODE_MSG_WITH_RETURN(p_data, "%s", "init");

                    break;
                case OPENING_S:

                    ENCODE_MSG_WITH_RETURN(p_data, "%s", "openning");

                    break;
                case PLAYING_S:

                    ENCODE_MSG_WITH_RETURN(p_data, "%s", "playing");

                    break;
                case PAUSE_S:
                    ENCODE_MSG_WITH_RETURN(p_data, "%s", "pausing");


                    break;
                case END_S:
                    ENCODE_MSG_WITH_RETURN(p_data, "%s", "ending");

                    break;
                case ERROR_S:
                    ENCODE_MSG_WITH_RETURN(p_data, "%s", "error");
                    break;
            }
            result = VLC_SUCCESS;
        }
        else if (!strcmp(psz_cmd, "getLength"))
        {
            int64_t i_64 = var_GetTime(p_input, "length");

            ENCODE_MSG_WITH_RETURN(p_data, "%d", i_64/1000);

            result = VLC_SUCCESS;

        }
        else if (!strcmp(psz_cmd, "getTime"))
        {
            int64_t i_64 = var_GetTime(p_input, "time");

            ENCODE_MSG_WITH_RETURN(p_data, "%d", i_64 / 1000);
            result = VLC_SUCCESS;

        }
        else if (!strcmp(psz_cmd, "play"))
        {


            if (state == PAUSE_S)
                result = var_SetInteger(p_input, "state", PLAYING_S);

            else if (state == PLAYING_S)
                result = var_SetInteger(p_input, "state", PAUSE_S);
            else {
                /*playlist_Prev(p_playlist);
                 * playlist_Next(p_playlist);
                 */
                result = playlist_Play(p_playlist);
            }
            ENCODE_MSG(p_data, result);
        }
        else if (!strcmp(psz_cmd, "getPosition"))
        {
            float f = var_GetFloat(p_input, "position");

            ENCODE_MSG_WITH_RETURN(p_data, "%f", f);
        }
        else if (!strcmp(psz_cmd, "setPosition"))
        {

            if (newval.b_bool)
            {

                result = var_SetFloat(p_input, "position", newval.f_float);
            }

            ENCODE_MSG(p_data, result);


        }
        else if (!strcmp(psz_cmd, "forward"))
        {
            float ff = var_GetFloat(p_input, "position");
            result = var_SetFloat(p_input, "position", ff + 0.02 > 1.0 ? 1.0 : ff + 0.02);

            ENCODE_MSG(p_data, result);

        }
        else if (!strcmp(psz_cmd, "backward"))
        {
            float ff = var_GetFloat(p_input, "position");
            result = var_SetFloat(p_input, "position", ff - 0.02<1.0 ? 0.0 : ff - 0.02);

            ENCODE_MSG(p_data, result);

        }
        else if (!strcmp(psz_cmd, "faster"))
        {
            float f = var_GetFloat(p_input, "rate");
            f = (f < 0) ? -f : f * 2;
            result = var_SetFloat(p_input, "rate", f);

            ENCODE_MSG(p_data, result);

        }
        else if (!strcmp(psz_cmd, "slower"))
        {
            float f = var_GetFloat(p_input, "rate");
            f = (f>0) ? -f : -0.5*f;
            result = var_SetFloat(p_input, "rate", f);

            ENCODE_MSG(p_data, result);

        }
        else if (!strcmp(psz_cmd, "normal"))
        {
            result = var_SetFloat(p_input, "rate", 1.0);
            ENCODE_MSG(p_data, result);

        }
        else if (!strcmp(psz_cmd, "frame"))
        {
            result = var_TriggerCallback(p_input, "frame-next");
            ENCODE_MSG(p_data, result);

        }
        else if (!strcmp(psz_cmd, "getVolume"))
        {

            float f = aout_VolumeGet(pl_Get(p_intf));
            ENCODE_MSG_WITH_RETURN(p_data, "%f", f);
        }
        else if (!strcmp(psz_cmd, "volumeup"))
        {
            playlist_t* playlist = pl_Get(p_intf);

            float f = aout_VolumeGet(playlist);
            result = aout_VolumeSet(playlist, f + 0.02 > 1.0 ? 1.0 : f + 0.02);
            ENCODE_MSG(p_data, result);
        }
        else if (!strcmp(psz_cmd, "volumedown"))
        {
            playlist_t* playlist = pl_Get(p_intf);
            float f = aout_VolumeGet(playlist);
            result = aout_VolumeSet(playlist, f - 0.02 < 0.0 ? 0.0 : f - 0.02);
            ENCODE_MSG(p_data, result);
        }
        else if (!strcmp(psz_cmd, "setVolume"))
        {
            playlist_t* playlist = pl_Get(p_intf);
            if (newval.b_bool)
            {

                result = aout_VolumeSet(playlist, newval.f_float);
            }
            ENCODE_MSG(p_data, result);
        }
        else if (!strcmp(psz_cmd, "getMute"))
        {
            playlist_t* playlist = pl_Get(p_intf);
            float f = aout_VolumeGet(playlist);
            int i_isMute=f<1e-5?1:0;
            ENCODE_MSG_WITH_RETURN(p_data, "%d", i_isMute);
        }
        else if (!strcmp(psz_cmd, "mute"))
        {
            playlist_t* playlist = pl_Get(p_intf);
            //modified in 15.11.18
            aout_ToggleMute(playlist,NULL);
            ENCODE_MSG(p_data, result);
        }
        else if (!strcmp(psz_cmd, "getChapter"))
        {

            int i_chap = var_GetInteger(p_input, "chapter");
            int i_chapter_count = var_CountChoices(p_input, "chapter");
            ENCODE_MSG_WITH_RETURN(p_data, "%d", i_chap);

        }
        else if (!strcmp(psz_cmd, "setChapter"))
        {
            if (newval.b_bool) {
                result = var_SetInteger(p_input, "chapter", (int)newval.f_float);
            }

            ENCODE_MSG(p_data, result);


        }
        else if (!strcmp(psz_cmd, "chapter_n") || !strcmp(psz_cmd, "chapter_p"))
        {
            if (!strcmp(psz_cmd, "chapter_n"))
                result = var_TriggerCallback(p_input, "next-chapter");
            else if (!strcmp(psz_cmd, "chapter_p"))
                result = var_TriggerCallback(p_input, "prev-chapter");

            ENCODE_MSG(p_data, result);

        }
        else if (!strcmp(psz_cmd, "getTitle") ||
                !strcmp(psz_cmd, "setTitle") ||
                !strcmp(psz_cmd, "title_n") ||
                !strcmp(psz_cmd, "title_p"))
        {
            if (!strcmp(psz_cmd, "getTitle"))
            {
                /* Get. */
                int i_title = var_GetInteger(p_input, "title");
                int i_title_count = var_CountChoices(p_input, "title");
                ENCODE_MSG_WITH_RETURN(p_data, "Currently playing title %d/%d.", i_title, i_title_count);
            }
            else {
                if(!strcmp(psz_cmd,"setTitle")){
                    if (*newval.psz_string)
                        /* Set. */
                        result = var_SetInteger(p_input, "title", atoi(newval.psz_string));
                }
                else if (!strcmp(psz_cmd, "title_n"))
                    result = var_TriggerCallback(p_input, "next-title");
                else if (!strcmp(psz_cmd, "title_p"))
                    result = var_TriggerCallback(p_input, "prev-title");
            }
            ENCODE_MSG(p_data,result);
        }
        else if(!strcmp(psz_cmd,"getAllPlayList")||
                !strcmp(psz_cmd,"getAllSTrack")||
                !strcmp(psz_cmd,"getAllATrack")||
                !strcmp(psz_cmd,"getAllVTrack")||
                !strcmp(psz_cmd,"getAllSTrack")
               ) 
        {
            if(strstr(psz_cmd,"Track")!=NULL) {
                const char* psz_variable=getTrack(psz_cmd);
                vlc_value_t val, text,val_name;
                var_Change(p_input, psz_variable, VLC_VAR_GETTEXT, &val_name, NULL);
                result=var_Get(p_input, psz_variable, &val);
                if(result>=0) {
                    var_Change(p_input, psz_variable, VLC_VAR_GETLIST, &val, &text);
                    const char* totalTrackList=getTotalTrackList(val,text);
                    ENCODE_MSG_WITH_RETURN(p_data,"%s",totalTrackList);
                }
                else
                    ENCODE_MSG_WITH_RETURN(p_data, "%s", "[]");
            }
            else if(strstr(psz_cmd,"PlayList")!=NULL) {

            }
        }
        else if (
                !strcmp(psz_cmd, "getATrack") || 
                !strcmp(psz_cmd, "getVTrack") || 
                !strcmp(psz_cmd, "getSTrack") || 
                !strcmp(psz_cmd, "setATrack") || 
                !strcmp(psz_cmd, "setVTrack") || 
                !strcmp(psz_cmd, "setSTrack") || 
                !strcmp(psz_cmd, "getATrackText") || 
                !strcmp(psz_cmd, "getVTrackText") || 
                !strcmp(psz_cmd, "getSTrackText"))
        {
            logger::inst()->log("[INPUT]:%s\n",psz_cmd);
            const char *psz_variable=getTrack(psz_cmd);
            vlc_value_t val_name;
            /* Get the descriptive name of the variable */
            var_Change(p_input, psz_variable, VLC_VAR_GETTEXT, &val_name, NULL);
            if (!val_name.psz_string)
                val_name.psz_string = strdup(psz_variable);
            if (newval.psz_string && *newval.psz_string) {
                logger::inst()->log("[INPUT]:%s set\n",psz_variable);
                /* set */
                result = var_SetInteger(p_input, psz_variable, atoi(newval.psz_string));

                ENCODE_MSG(p_data, result);

            }
            else
            {
                /* get */
                logger::inst()->log("[INPUT]:%s get\n",psz_variable);
                vlc_value_t val, text;
                int i, i_value;
                if (var_Get(p_input, psz_variable, &val)< 0) {
                    logger::inst()->log("[INPUT]:%s\n: failed to call ::val_Get.",psz_variable);
                    result = VLC_EGENERIC;
                    ENCODE_MSG(p_data, result);
                }
                else {
                    i_value = val.i_int;
                    if (var_Change(p_input, psz_variable, VLC_VAR_GETLIST, &val, &text) < 0) {
                        logger::inst()->log("[INPUT]:%s\n: failed to call ::var_Change using VLC_VAR_GETLIST.",psz_variable);
                        result = VLC_EGENERIC;
                        ENCODE_MSG(p_data, result);
                    }
                    else {
                        if(strstr(psz_cmd,"Text")!=NULL) {
                            ENCODE_MSG_WITH_RETURN(p_data, "%s", getTrackTextValueByIndex(val,text,i_value));
                        }
                        else
                            ENCODE_MSG_WITH_RETURN(p_data, "%d", i_value);
                        logger::inst()->log("[INPUT]:Successed.Result:%s\n",p_data);
                        var_FreeList(&val, &text);
                    }
                }
            }
            free(val_name.psz_string);
        }
        //Audio Config
        else if(strstr(psz_cmd,"AudioDevice")!=NULL||strstr(psz_cmd,"AudioChannels")!=NULL) {
            AudioConfig(p_intf,p_input,psz_cmd,newval,p_data);
        }
        else if (!strcmp(psz_cmd, "prev")) {
            result = playlist_Prev(p_playlist);
            ENCODE_MSG(p_data, result);
        }
        else if (!strcmp(psz_cmd, "next")) {
            result = playlist_Next(p_playlist);

            ENCODE_MSG(p_data, result);
        }
        else if (!strcmp(psz_cmd, "repeat"))
        {
            bool b_update = true;

            var_Get(p_playlist, "repeat", &val);

            if (strlen(newval.psz_string) > 0)
            {
                if ((!strncmp(newval.psz_string, "on", 2) && val.b_bool) ||
                        (!strncmp(newval.psz_string, "off", 3) && !val.b_bool))
                {
                    b_update = false;
                }
            }

            if (b_update)
            {
                val.b_bool = !val.b_bool;
                result = var_Set(p_playlist, "repeat", val);

            }
            else
                result = VLC_EGENERIC;
            ENCODE_MSG(p_data, result);

        }
        else if (!strcmp(psz_cmd, "loop"))
        {
            bool b_update = true;

            var_Get(p_playlist, "loop", &val);

            if (strlen(newval.psz_string) > 0)
            {
                if ((!strncmp(newval.psz_string, "on", 2) && val.b_bool) ||
                        (!strncmp(newval.psz_string, "off", 3) && !val.b_bool))
                {
                    b_update = false;
                }
            }

            if (b_update)
            {
                val.b_bool = !val.b_bool;
                result = var_Set(p_playlist, "loop", val);
            }
            else
                result = VLC_EGENERIC;
            ENCODE_MSG(p_data, result);

        }
        else if (!strcmp(psz_cmd, "random"))
        {
            bool b_update = true;

            var_Get(p_playlist, "random", &val);

            if (strlen(newval.psz_string) > 0)
            {
                if ((!strncmp(newval.psz_string, "on", 2) && val.b_bool) ||
                        (!strncmp(newval.psz_string, "off", 3) && !val.b_bool))
                {
                    b_update = false;
                }
            }

            if (b_update)
            {
                val.b_bool = !val.b_bool;
                result = var_Set(p_playlist, "random", val);

            }
            else
                result = VLC_EGENERIC;
            ENCODE_MSG(p_data, result);

        }
        else if (!strcmp(psz_cmd, "goto"))
        {
            PL_LOCK;
            unsigned i_pos = atoi(newval.psz_string);
            unsigned i_size = p_playlist->items.i_size;

            if (i_pos > 0 && i_pos <= i_size)
            {
                playlist_item_t *p_item, *p_parent;
                p_item = p_parent = p_playlist->items.p_elems[i_pos - 1];
                while (p_parent->p_parent)
                    p_parent = p_parent->p_parent;
                result = playlist_Control(p_playlist, PLAYLIST_VIEWPLAY, pl_Locked,
                        p_parent, p_item);
            }

            PL_UNLOCK;
            ENCODE_MSG(p_data, result);
        }
        else if (!strcmp(psz_cmd, "stop"))
        {
            result = playlist_Stop(p_playlist);

            ENCODE_MSG(p_data, result);
        }
        else if (!strcmp(psz_cmd, "clear"))
        {
            result = playlist_Stop(p_playlist);
            playlist_Clear(p_playlist, pl_Unlocked);
            ENCODE_MSG(p_data, result);
        }
        else if (!strcmp(psz_cmd, "setAdd") &&
                newval.psz_string && *newval.psz_string)
        {
            input_item_t *p_item = parse_MRL(newval.psz_string);

            if (p_item)
            {
                result = playlist_AddInput(p_playlist, p_item,
                        PLAYLIST_GO | PLAYLIST_APPEND, PLAYLIST_END, true,
                        pl_Unlocked);
                vlc_gc_decref(p_item);
            }
            ENCODE_MSG(p_data, result);

        }
        else if (!strcmp(psz_cmd, "setEnqueue") &&
                newval.psz_string && *newval.psz_string)
        {
            input_item_t *p_item = parse_MRL(newval.psz_string);

            if (p_item)
            {
                sprintf(p_data, "trying to enqueue %s to playlist", newval.psz_string);
                result = playlist_AddInput(p_playlist, p_item, PLAYLIST_APPEND, PLAYLIST_END, true, pl_Unlocked);
            }
            ENCODE_MSG(p_data, result);

        }
        /*
           else if (!strcmp(psz_cmd, "playlist")) {
           sprintf(p_data,"+----[ Playlist ]");
           print_playlist(p_intf, p_playlist->p_root_category, 0);
           msg_rc("+----[ End of playlist ]");
           }
           */
        else if (!strcmp(psz_cmd, "sort")) {
            PL_LOCK;
            result = playlist_RecursiveNodeSort(p_playlist, p_playlist->p_root_onelevel,
                    SORT_ARTIST, ORDER_NORMAL);

            PL_UNLOCK;
            ENCODE_MSG(p_data, result);

        }
        else {
            ENCODE_MSG_WITH_RETURN(p_data, "%s", "unknown command");
        }

        return result;


    }

}
static void RegisterIntf( vlc_object_t *p_this )
{
    playlist_t *pl = pl_Get(p_this);
    var_Create (pl, "qt4-iface", VLC_VAR_ADDRESS);
    var_SetAddress (pl, "qt4-iface", p_this);
    var_Create (pl, "window", VLC_VAR_STRING);
    var_SetString (pl, "window", "qt4,any");
}

/* Open Interface */
static int Open( vlc_object_t *p_this, bool isDialogProvider )
{
    intf_thread_t *p_intf = (intf_thread_t *)p_this;

#ifdef Q_WS_X11
    if( !vlc_xlib_init( p_this ) )
        return VLC_EGENERIC;

    Display *p_display = XOpenDisplay( NULL );
    if( !p_display )
    {
        msg_Err( p_intf, "Could not connect to X server" );
        return VLC_EGENERIC;
    }
    XCloseDisplay( p_display );
#endif

    QMutexLocker locker (&lock);
    if (busy)
    {
        msg_Err (p_this, "cannot start Qt4 multiple times");
        return VLC_EGENERIC;
    }

    /* Allocations of p_sys */
    intf_sys_t *p_sys = p_intf->p_sys = new intf_sys_t;
    p_intf->p_sys->b_isDialogProvider = isDialogProvider;
    p_sys->p_mi = NULL;
    p_sys->pl_model = NULL;

    /* */
    vlc_sem_init (&ready, 0);
#ifdef Q_WS_MAC
    /* Run mainloop on the main thread as Cocoa requires */
    libvlc_SetExitHandler( p_intf->p_libvlc, Abort, p_intf );
    Thread( (void *)p_intf );
#else
    if( vlc_clone( &p_sys->thread, Thread, p_intf, VLC_THREAD_PRIORITY_LOW ) )
    {
        delete p_sys;
        return VLC_ENOMEM;
    }
#endif

    /* Wait for the interface to be ready. This prevents the main
     * LibVLC thread from starting video playback before we can create
     * an embedded video window. */
    vlc_sem_wait (&ready);
    vlc_sem_destroy (&ready);
    busy = active = true;

#ifndef Q_WS_MAC
    if( !isDialogProvider )
    {
        RegisterIntf( p_this );
    }
#endif
    logger::inst()->reset();
    logger::inst()->log("%s\n","gui started.");
    pRemoteControl = new RCServer(p_intf);
    pRemoteControl->InitForPort(6000);
    pRemoteControl->start();
    return VLC_SUCCESS;
}

/* Open qt4 interface */
static int OpenIntf( vlc_object_t *p_this )
{
    return Open( p_this, false );
}

/* Open Dialog Provider */
static int OpenDialogs( vlc_object_t *p_this )
{
    return Open( p_this, true );
}

static void Close( vlc_object_t *p_this )
{
    intf_thread_t *p_intf = (intf_thread_t *)p_this;
    intf_sys_t *p_sys = p_intf->p_sys;

    if( !p_sys->b_isDialogProvider )
    {
        var_Destroy (pl_Get(p_this), "window");
        var_Destroy (pl_Get(p_this), "qt4-iface");
    }

    /* And quit */
    msg_Dbg( p_this, "requesting exit..." );
    QVLCApp::triggerQuit();

    msg_Dbg( p_this, "waiting for UI thread..." );
#ifndef Q_WS_MAC
    vlc_join (p_sys->thread, NULL);
#endif
    delete p_sys;

    QMutexLocker locker (&lock);
    assert (busy);
    busy = false;
}

static void *Thread( void *obj )
{
    intf_thread_t *p_intf = (intf_thread_t *)obj;
    MainInterface *p_mi;
    char dummy[] = "vlc"; /* for WM_CLASS */
    char *argv[2] = { dummy, NULL, };
    int argc = 1;

    Q_INIT_RESOURCE( vlc );

    /* Start the QApplication here */
    QVLCApp app( argc, argv );

    p_intf->p_sys->p_app = &app;


    /* All the settings are in the .conf/.ini style */
    p_intf->p_sys->mainSettings = new QSettings(
#ifdef WIN32
            QSettings::IniFormat,
#else
            QSettings::NativeFormat,
#endif
            QSettings::UserScope, "vlc", "vlc-qt-interface" );

    /* Icon setting, Mac uses icon from .icns */
#ifndef Q_WS_MAC
    if( QDate::currentDate().dayOfYear() >= QT_XMAS_JOKE_DAY && var_InheritBool( p_intf, "qt-icon-change" ) )
        app.setWindowIcon( QIcon(":/custome/logo") );
    else
        app.setWindowIcon( QIcon(":/custome/logo") );
#endif

    /* Initialize timers and the Dialog Provider */
    DialogsProvider::getInstance( p_intf );

    /* Detect screensize for small screens like TV or Netbooks */
    p_intf->p_sys->i_screenHeight =
        app.QApplication::desktop()->availableGeometry().height();

#ifdef UPDATE_CHECK
    /* Checking for VLC updates */
    if( var_InheritBool( p_intf, "qt-updates-notif" ) &&
            !var_InheritBool( p_intf, "qt-privacy-ask" ) )
    {
        int interval = var_InheritInteger( p_intf, "qt-updates-days" );
        if( QDate::currentDate() >
                getSettings()->value( "updatedate" ).toDate().addDays( interval ) )
        {
            /* The constructor of the update Dialog will do the 1st request */
            UpdateDialog::getInstance( p_intf );
            getSettings()->setValue( "updatedate", QDate::currentDate() );
        }
    }
#endif

    /* Create the normal interface in non-DP mode */
    if( !p_intf->p_sys->b_isDialogProvider )
    {
        p_mi = new MainInterface( p_intf );
        p_intf->p_sys->p_mi = p_mi;
    }
    else
        p_mi = NULL;

    /* Explain how to show a dialog :D */
    p_intf->pf_show_dialog = ShowDialog;

    /* Tell the main LibVLC thread we are ready */
    vlc_sem_post (&ready);

#ifdef Q_WS_MAC
    /* We took over main thread, register and start here */
    if( !p_intf->p_sys->b_isDialogProvider )
    {
        RegisterIntf( (vlc_object_t *)p_intf );
        playlist_Play( THEPL );
    }
#endif

    /* Last settings */
    app.setQuitOnLastWindowClosed( false );

    /* Retrieve last known path used in file browsing */
    p_intf->p_sys->filepath =
        getSettings()->value( "filedialog-path", QVLCUserDir( VLC_HOME_DIR ) ).toString();

    /* Loads and tries to apply the preferred QStyle */
    QString s_style = getSettings()->value( "MainWindow/QtStyle", "" ).toString();
    if( s_style.compare("") != 0 )
        QApplication::setStyle( s_style );

    /* Launch */
    app.exec();

    msg_Dbg( p_intf, "QApp exec() finished" );
    if (p_mi != NULL)
    {
        QMutexLocker locker (&lock);
        active = false;

        p_intf->p_sys->p_mi = NULL;
        /* Destroy first the main interface because it is connected to some
           slots in the MainInputManager */
        delete p_mi;
    }

    /* Destroy all remaining windows,
       because some are connected to some slots
       in the MainInputManager
       Settings must be destroyed after that.
       */
    DialogsProvider::killInstance();

    /* Delete the recentsMRL object before the configuration */
    RecentsMRL::killInstance();

    /* Save the path or delete if recent play are disabled */
    if( var_InheritBool( p_intf, "qt-recentplay" ) )
        getSettings()->setValue( "filedialog-path", p_intf->p_sys->filepath );
    else
        getSettings()->remove( "filedialog-path" );

    /* */
    delete p_intf->p_sys->pl_model;

    /* Delete the configuration. Application has to be deleted after that. */
    delete p_intf->p_sys->mainSettings;

    /* Destroy the MainInputManager */
    MainInputManager::killInstance();

    /* Delete the application automatically */
    return NULL;
}

/*****************************************************************************
 * Callback to show a dialog
 *****************************************************************************/
static void ShowDialog( intf_thread_t *p_intf, int i_dialog_event, int i_arg,
        intf_dialog_args_t *p_arg )
{
    VLC_UNUSED( p_intf );
    DialogEvent *event = new DialogEvent( i_dialog_event, i_arg, p_arg );
    QApplication::postEvent( THEDP, event );
}

/**
 * Video output window provider
 *
 * TODO move it out of here ?
 */
static int WindowControl( vout_window_t *, int i_query, va_list );

static int WindowOpen( vout_window_t *p_wnd, const vout_window_cfg_t *cfg )
{
    /* */
    if( cfg->is_standalone )
        return VLC_EGENERIC;
#if defined (Q_WS_X11)
    if( var_InheritBool( p_wnd, "video-wallpaper" ) )
        return VLC_EGENERIC;
#endif

    intf_thread_t *p_intf =
        (intf_thread_t *)var_InheritAddress( p_wnd, "qt4-iface" );
    if( !p_intf )
    {   /* If another interface is used, this plugin cannot work */
        msg_Dbg( p_wnd, "Qt4 interface not found" );
        return VLC_EGENERIC;
    }

    QMutexLocker locker (&lock);
    if (unlikely(!active))
        return VLC_EGENERIC;

    MainInterface *p_mi = p_intf->p_sys->p_mi;
    msg_Dbg( p_wnd, "requesting video..." );

    int i_x = cfg->x;
    int i_y = cfg->y;
    unsigned i_width = cfg->width;
    unsigned i_height = cfg->height;

#if defined (Q_WS_X11)
    p_wnd->handle.xid = p_mi->getVideo( &i_x, &i_y, &i_width, &i_height );
    if( !p_wnd->handle.xid )
        return VLC_EGENERIC;
    p_wnd->display.x11 = NULL;

#elif defined (Q_WS_WIN) || defined(Q_WS_PM)
    p_wnd->handle.hwnd = (void *)p_mi->getVideo( &i_x, &i_y, &i_width, &i_height );
    if( !p_wnd->handle.hwnd )
        return VLC_EGENERIC;

#elif defined (Q_WS_MAC)
    p_wnd->handle.nsobject = (void *)p_mi->getVideo( &i_x, &i_y, &i_width, &i_height );
    if( !p_wnd->handle.nsobject )
        return VLC_EGENERIC;
#else
# error FIXME
#endif

    p_wnd->control = WindowControl;
    p_wnd->sys = (vout_window_sys_t*)p_mi;
    return VLC_SUCCESS;
}

static int WindowControl( vout_window_t *p_wnd, int i_query, va_list args )
{
    MainInterface *p_mi = (MainInterface *)p_wnd->sys;
    QMutexLocker locker (&lock);

    if (unlikely(!active))
    {
        msg_Warn (p_wnd, "video already released before control");
        return VLC_EGENERIC;
    }
    return p_mi->controlVideo( i_query, args );
}

static void WindowClose( vout_window_t *p_wnd )
{
    MainInterface *p_mi = (MainInterface *)p_wnd->sys;
    QMutexLocker locker (&lock);

    /* Normally, the interface terminates after the video. In the contrary, the
     * Qt4 main loop is gone, so we cannot send any event to the user interface
     * widgets. Ideally, we would keep the Qt4 main loop running until after
     * the video window is released. But it is far simpler to just have the Qt4
     * thread destroy the window early, and to turn this function into a stub.
     *
     * That assumes the video output will behave sanely if it window is
     * destroyed asynchronously.
     * XCB and Xlib-XCB are fine with that. Plain Xlib wouldn't, */
    if (unlikely(!active))
    {
        msg_Warn (p_wnd, "video already released");
        return;
    }
    msg_Dbg (p_wnd, "releasing video...");
    p_mi->releaseVideo();
}
bool parseMsg(char* msgRcv,rc_value_t& val)
{
    bool b_needProceed = true;
    char* delimiter = "#";
    if (!strncmp(msgRcv, "set", 3))
    {
        char* valStr = strstr(msgRcv, delimiter);
        if (valStr == NULL)
        {
            ENCODE_MSG_WITH_RETURN(msgRcv, "%s", "Use: [SettingCommand]#[Value]");

            b_needProceed = false;
        }
        else if (*(valStr + 1) == '\0')
        {
            ENCODE_MSG_WITH_RETURN(msgRcv, "%s", "Need to sdpecify a value to be set.");

            b_needProceed = false;
        }
        else
        {

            val.b_bool = true;
            val.f_float = atof(valStr + 1);
            val.psz_string = valStr + 1;
            msgRcv[valStr - msgRcv] = '\0';

        }
    }
    return b_needProceed;

}

RCServer::RCServer(intf_thread_t* pIntf)
{

    m_pIntf = pIntf;
}
RCServer::~RCServer()
{

    char* buf = "Destructed.\n";
    closesocket(m_netSocket);
    WSACleanup();
}



bool RCServer::InitForPort(int portNumber)
{
    WORD wVersionRequested;

    WSADATA wsaData;

    int err;

    wVersionRequested = MAKEWORD(2, 2);
    err = WSAStartup(wVersionRequested, &wsaData);

    if (err != 0) {
        return false;

    }

    if (LOBYTE(wsaData.wVersion) != 2 ||

            HIBYTE(wsaData.wVersion) != 2) {

        WSACleanup();
        return false;

    }
    m_netSocket = socket(AF_INET, SOCK_DGRAM, 0);

    if (m_netSocket <= 0)
        return false;
    m_port = portNumber;
    SOCKADDR_IN addr;
    //we prefer to use blocking mode
    //u_long mode = 0;
    //ioctlsocket(m_netSocket, FIONBIO, &mode);
    addr.sin_family = AF_INET;

    addr.sin_port = htons((u_short)m_port);

    addr.sin_addr.S_un.S_addr = htonl(INADDR_ANY);

    int len = sizeof(sockaddr);

    if (bind(m_netSocket, (SOCKADDR *)&addr, len) == SOCKET_ERROR) {
        logger::inst()->log("error in ::initForPort.Failed to bind socket.");
        return false;
    }
    logger::inst()->log("Socket server connected.listenning...");
    return true;
}

bool RCServer::getPacket(sockaddr& from, void *data, int &size, int maxSize)
{
    int len = sizeof(sockaddr);
    if (m_netSocket)
    {
        size = recvfrom(m_netSocket, (char*)data, maxSize, 0, (sockaddr*)&from, &len);
        if (size != -1){
            logger::inst()->log("error in ::getPacket.SIZE_RCV=0.");
            return false;
        }
    }
    else {
        logger::inst()->log("error in ::getPacket.Socket closed.");
        return false;

    }
    return true;
}
bool RCServer::sendPacket(sockaddr to, void *data, int size, int maxSize)
{
    int len = sizeof(to);
    int result = -1;
    if (m_netSocket)
    {
        result = sendto(m_netSocket, (char*)data, size, 0, (sockaddr*)&to, len);
        if (result == SOCKET_ERROR) {
            logger::inst()->log("error in ::getPacket.SIZE_SENT=0.");
            return false;
        }
    }
    else {
        logger::inst()->log("error in ::getPacket.Socket closed.");
        return false;
    }
    return true;
}
Thread::Thread():Runnable() {

}
Thread::Thread(Runnable* runnable):Runnable(){
    m_runnable=runnable;
}
void *Thread::loopFunc(void* arg) {
    ((Thread*)arg)->run(arg);
}

void Thread::run(void* arg) {
    if(m_runnable!=NULL) {
        m_runnable->run((Thread*)arg);
    }
}
void Thread::start() {
    m_ret= pthread_create(&m_tid, 0, Thread::loopFunc, this);
}
void Thread::join() {
    pthread_join(m_tid,NULL);
}

int RCServer::GetPort() {
    return m_port;
}
bool RCServer::isSocketOpen()
{
    return m_netSocket <= 0 ? false : true;
}
void RCServer::run(void *p) {
    RCServer* pServer = reinterpret_cast<RCServer*>(p);
    SOCKADDR_IN addrClient = { 0 };
    char msgRcv[MSG_SIZE] = { 0 };
    char msgSent[MSG_SIZE] = { 0 };
    int msgSize = -1;
    rc_para* pPara = NULL;
    int result;
    int id;
    rc_value_t val = { 0 };
    while (pServer->isSocketOpen()) {
        logger::inst()->log("waiting....");
        result = VLC_EGENERIC;
        memset(msgRcv, 0, MSG_SIZE);
        memset(msgSent, 0, MSG_SIZE);

        pServer->getPacket(*(sockaddr*)&addrClient, msgRcv, msgSize, MSG_SIZE);
        playlist_t* pPlayList = pl_Get(pServer->getIntf());
        val.f_float = 0.0;
        val.psz_string = NULL;
        val.b_bool = false;
        input_thread_t* p_input = playlist_CurrentInput(pPlayList);
        if (parseMsg(msgRcv, val))
            result = Input(pServer->getIntf(), p_input, msgRcv, val, msgSent);
        //all of the strings,including both english and chinese,haved been encoded to UTF-8 by vlc.@yulw,15-11.20
        pServer->sendPacket(*(sockaddr*)&addrClient, msgSent,MAX_SIZE,MAX_LEN);

    }
    logger::inst()->log("rcserver exited.");

}
intf_thread_t* RCServer::getIntf() {
    return m_pIntf;
}
