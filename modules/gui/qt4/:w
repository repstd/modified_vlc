/*****************************************************************************
 * qt4.cpp : QT4 interface
 * gg
 ****************************************************************************
 * Copyright © 2006-2009 the VideoLAN team
 * $Id: 7ff935fc934d7a3e35201c34cbae8ef6a7a2614d $
 *
 * Authors: Clément Stenac <zorglub@videolan.org>
 *          Jean-Baptiste Kempf <jb@videolan.org>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
 *****************************************************************************/

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif

#include <QApplication>
#include <QDate>
#include <QMutex>

#include "qt4.hpp"

#include "input_manager.hpp"    /* THEMIM destruction */
#include "dialogs_provider.hpp" /* THEDP creation */
#include "main_interface.hpp"   /* MainInterface creation */
#include "dialogs/help.hpp"     /* Launch Update */
#include "recents.hpp"          /* Recents Item destruction */
#include "util/qvlcapp.hpp"     /* QVLCApplication definition */
#include "components/playlist/playlist_model.hpp" /* for ~PLModel() */
#include <vlc_aout_intf.h>
#include "remoteControlServer.hpp"
#include "rclog.h"
#include "vlc_charset.h"
#ifdef Q_WS_X11
#include <vlc_xlib.h>
#endif

#include "../../../share/icons/32x32/vlc.xpm"
#include "../../../share/icons/32x32/vlc-xmas.xpm"
#include <vlc_plugin.h>
#include <vlc_vout_window.h>
#include <vlc_input.h>
#include <locale>
#include <iostream>
#include <string>
#include <sstream>
#include <vlc_aout.h>
#include <vlc_aout_intf.h>
#include <vlc_aout_intf.h>
#include <vlc_modules.h>
#include <map>
#include <vector>
#include <algorithm>
#include <unistd.h>
#include <errno.h>
#include <vlc_config.h>
#include "ini/inifile.h"
using namespace std;
#ifdef WIN32 /* For static builds */
#include <QtPlugin>
    Q_IMPORT_PLUGIN(qjpeg)
Q_IMPORT_PLUGIN(qtaccessiblewidgets)
#endif

    /*****************************************************************************
     * Local prototypes.
     *****************************************************************************/
    static int  OpenIntf     ( vlc_object_t * );
    static int  OpenDialogs  ( vlc_object_t * );
    static int  Open         ( vlc_object_t *, bool );
    static void Close        ( vlc_object_t * );
    static int  WindowOpen   ( vout_window_t *, const vout_window_cfg_t * );
    static void WindowClose  ( vout_window_t * );
    static void *Thread      ( void * );
    static void ShowDialog   ( intf_thread_t *, int, int, intf_dialog_args_t * );

    /*****************************************************************************
     * Module descriptor
     *****************************************************************************/
#define ADVANCED_PREFS_TEXT N_( "Show advanced preferences over simple ones" )
#define ADVANCED_PREFS_LONGTEXT N_( "Show advanced preferences and not simple "\
        "preferences when opening the preferences "\
        "dialog." )

#define SYSTRAY_TEXT N_( "Systray icon" )
#define SYSTRAY_LONGTEXT N_( "Show an icon in the systray " \
        "allowing you to control VLC media player " \
        "for basic actions." )

#define MINIMIZED_TEXT N_( "Start VLC with only a systray icon" )
#define MINIMIZED_LONGTEXT N_( "VLC will start with just an icon in " \
        "your taskbar" )

#define KEEPSIZE_TEXT N_( "Resize interface to the native video size" )
#define KEEPSIZE_LONGTEXT N_( "You have two choices:\n" \
        " - The interface will resize to the native video size\n" \
        " - The video will fit to the interface size\n " \
        "By default, interface resize to the native video size." )

#define TITLE_TEXT N_( "Show playing item name in window title" )
#define TITLE_LONGTEXT N_( "Show the name of the song or video in the " \
        "controller window title." )

#define NOTIFICATION_TEXT N_( "Show notification popup on track change" )
#define NOTIFICATION_LONGTEXT N_( \
        "Show a notification popup with the artist and track name when " \
        "the current playlist item changes, when VLC is minimized or hidden." )

#define ADVANCED_OPTIONS_TEXT N_( "Advanced options" )
#define ADVANCED_OPTIONS_LONGTEXT N_( "Show all the advanced options " \
        "in the dialogs." )

#define OPACITY_TEXT N_( "Windows opacity between 0.1 and 1" )
#define OPACITY_LONGTEXT N_( "Sets the windows opacity between 0.1 and 1 " \
        "for main interface, playlist and extended panel."\
        " This option only works with Windows and " \
        "X11 with composite extensions." )

#define OPACITY_FS_TEXT N_( "Fullscreen controller opacity between 0.1 and 1" )
#define OPACITY_FS_LONGTEXT N_( "Sets the fullscreen controller opacity between 0.1 and 1 " \
        "for main interface, playlist and extended panel."\
        " This option only works with Windows and " \
        "X11 with composite extensions." )


#define ERROR_TEXT N_( "Show unimportant error and warnings dialogs" )

#define UPDATER_TEXT N_( "Activate the updates availability notification" )
#define UPDATER_LONGTEXT N_( "Activate the automatic notification of new " \
        "versions of the software. It runs once every " \
        "two weeks." )
#define UPDATER_DAYS_TEXT N_("Number of days between two update checks")

#define SAVEVOL_TEXT N_( "Automatically save the volume on exit" )

#define PRIVACY_TEXT N_( "Ask for network policy at start" )

#define RECENTPLAY_TEXT N_( "Save the recently played items in the menu" )

#define RECENTPLAY_FILTER_TEXT N_( "List of words separated by | to filter" )
#define RECENTPLAY_FILTER_LONGTEXT N_( "Regular expression used to filter " \
        "the recent items played in the player" )

#define SLIDERCOL_TEXT N_( "Define the colors of the volume slider " )
#define SLIDERCOL_LONGTEXT N_( "Define the colors of the volume slider\n" \
        "By specifying the 12 numbers separated by a ';'\n" \
        "Default is '255;255;255;20;226;20;255;176;15;235;30;20'\n" \
        "An alternative can be '30;30;50;40;40;100;50;50;160;150;150;255' ")

#define QT_MODE_TEXT N_( "Selection of the starting mode and look " )
#define QT_MODE_LONGTEXT N_( "Start VLC with:\n" \
        " - normal mode\n"  \
        " - a zone always present to show information " \
        "as lyrics, album arts...\n" \
        " - minimal mode with limited controls" )

#define QT_FULLSCREEN_TEXT N_( "Show a controller in fullscreen mode" )
#define QT_NATIVEOPEN_TEXT N_( "Embed the file browser in open dialog" )

#define FULLSCREEN_NUMBER_TEXT N_( "Define which screen fullscreen goes" )
#define FULLSCREEN_NUMBER_LONGTEXT N_( "Screennumber of fullscreen, instead of " \
        "same screen where interface is" )

#define QT_AUTOLOAD_EXTENSIONS_TEXT N_( "Load extensions on startup" )
#define QT_AUTOLOAD_EXTENSIONS_LONGTEXT N_( "Automatically load the "\
        "extensions module on startup" )

#define QT_MINIMAL_MODE_TEXT N_("Start in minimal view (without menus)" )

#define QT_BGCONE_TEXT N_( "Display background cone or art" )
#define QT_BGCONE_LONGTEXT N_( "Display background cone or current album art " \
        "when not playing. " \
        "Can be disabled to prevent burning screen." )
#define QT_BGCONE_EXPANDS_TEXT N_( "Expanding background cone or art." )
#define QT_BGCONE_EXPANDS_LONGTEXT N_( "Background art fits window's size" )

#define QT_DISABLE_VOLUME_KEYS_TEXT N_( "Ignore keyboard volume buttons." )
#define QT_DISABLE_VOLUME_KEYS_LONGTEXT N_(                                             \
        "With this option checked, the volume up, volume down and mute buttons on your "    \
        "keyboard will always change your system volume. With this option unchecked, the "  \
        "volume buttons will change VLC's volume when VLC is selected and change the "      \
        "system volume when VLC is not selected." )

#define QT_PAUSE_MINIMIZED_TEXT N_( "Pause the video playback when minimized" )
#define QT_PAUSE_MINIMIZED_LONGTEXT N_( \
        "With this option enabled, the playback will be automatically paused when minimizing the window." )

#define ICONCHANGE_TEXT N_( "Allow automatic icon changes")
#define ICONCHANGE_LONGTEXT N_( \
        "This option allows the interface to change its icon on various occasions.")

    /**********************************************************************/
vlc_module_begin ()
    set_shortname( "Qt" )
    set_description( N_("Qt interface") )
    set_category( CAT_INTERFACE )
set_subcategory( SUBCAT_INTERFACE_MAIN )
    set_capability( "interface", 151 )
set_callbacks( OpenIntf, Close )

    add_shortcut("qt")

    add_bool( "qt-minimal-view", false, QT_MINIMAL_MODE_TEXT,
            QT_MINIMAL_MODE_TEXT, false );

add_bool( "qt-system-tray",
#ifdef HAVE_MAEMO
        false,
#else
        true,
#endif
        SYSTRAY_TEXT, SYSTRAY_LONGTEXT, false)
add_bool( "qt-notification", true, NOTIFICATION_TEXT,
        NOTIFICATION_LONGTEXT, false )
add_bool( "qt-start-minimized", false, MINIMIZED_TEXT,
        MINIMIZED_LONGTEXT, true)
add_bool( "qt-pause-minimized", false, QT_PAUSE_MINIMIZED_TEXT,
        QT_PAUSE_MINIMIZED_LONGTEXT, false )

add_float_with_range( "qt-opacity", 1., 0.1, 1., OPACITY_TEXT,
        OPACITY_LONGTEXT, false )
add_float_with_range( "qt-fs-opacity", 0.8, 0.1, 1., OPACITY_FS_TEXT,
        OPACITY_FS_LONGTEXT, false )

add_bool( "qt-video-autoresize", true, KEEPSIZE_TEXT,
        KEEPSIZE_LONGTEXT, false )
add_bool( "qt-name-in-title", true, TITLE_TEXT,
        TITLE_LONGTEXT, false )
add_bool( "qt-fs-controller", true, QT_FULLSCREEN_TEXT,
        QT_FULLSCREEN_TEXT, false )

add_bool( "qt-recentplay", true, RECENTPLAY_TEXT,
        RECENTPLAY_TEXT, false )
add_string( "qt-recentplay-filter", "",
        RECENTPLAY_FILTER_TEXT, RECENTPLAY_FILTER_LONGTEXT, false )

#ifdef UPDATE_CHECK
add_bool( "qt-updates-notif", true, UPDATER_TEXT,
        UPDATER_LONGTEXT, false )
add_integer_with_range( "qt-updates-days", 3, 0, 180,
        UPDATER_DAYS_TEXT, UPDATER_DAYS_TEXT, false )
#endif

add_bool( "qt-autosave-volume", true, SAVEVOL_TEXT,
        SAVEVOL_TEXT, true )
#ifdef WIN32
add_bool( "qt-disable-volume-keys"             /* name */,
        true                                 /* default value */,
        QT_DISABLE_VOLUME_KEYS_TEXT          /* text */,
        QT_DISABLE_VOLUME_KEYS_LONGTEXT      /* longtext */,
        false                                /* advanced mode only */)
#endif

add_bool( "qt-embedded-open", false, QT_NATIVEOPEN_TEXT,
        QT_NATIVEOPEN_TEXT, false )


add_bool( "qt-advanced-pref", false, ADVANCED_PREFS_TEXT,
        ADVANCED_PREFS_LONGTEXT, false )
add_bool( "qt-error-dialogs", true, ERROR_TEXT,
        ERROR_TEXT, false )

add_string( "qt-slider-colours", "153;210;153;20;210;20;255;199;15;245;39;29",
        SLIDERCOL_TEXT, SLIDERCOL_LONGTEXT, false )

add_bool( "qt-privacy-ask", true, PRIVACY_TEXT, PRIVACY_TEXT,
        false )
change_private ()

    add_integer( "qt-fullscreen-screennumber", -1, FULLSCREEN_NUMBER_TEXT,
            FULLSCREEN_NUMBER_LONGTEXT, false );

add_bool( "qt-autoload-extensions", true,
        QT_AUTOLOAD_EXTENSIONS_TEXT, QT_AUTOLOAD_EXTENSIONS_LONGTEXT,
        false )

add_bool( "qt-bgcone", true, QT_BGCONE_TEXT, QT_BGCONE_LONGTEXT, true )
add_bool( "qt-bgcone-expands", false, QT_BGCONE_EXPANDS_TEXT,
        QT_BGCONE_EXPANDS_LONGTEXT, true )

add_bool( "qt-icon-change", true, ICONCHANGE_TEXT, ICONCHANGE_LONGTEXT, true )

add_obsolete_bool( "qt-blingbling" )      /* Suppressed since 1.0.0 */
add_obsolete_integer( "qt-display-mode" ) /* Suppressed since 1.1.0 */

add_obsolete_bool( "qt-adv-options" )     /* Since 2.0.0 */
add_obsolete_bool( "qt-volume-complete" ) /* Since 2.0.0 */
add_obsolete_integer( "qt-startvolume" )  /* Since 2.0.0 */

cannot_unload_broken_library()

add_submodule ()
    set_description( "Dialogs provider" )
    set_capability( "dialogs provider", 51 )

set_callbacks( OpenDialogs, Close )

#if defined(Q_WS_X11) || defined(Q_WS_WIN) || defined(Q_WS_MAC)  || defined(Q_WS_PM)
add_submodule ()
#if defined(Q_WS_X11)
    set_capability( "vout window xid", 0 )
#elif defined(Q_WS_WIN) || defined(Q_WS_PM)
    set_capability( "vout window hwnd", 0 )
#elif defined(Q_WS_MAC)
    set_capability( "vout window nsobject", 0 )
#endif
set_callbacks( WindowOpen, WindowClose )
#endif

vlc_module_end ()

    /*****************************************/

    /* Ugly, but the Qt4 interface assumes single instance anyway */
    static vlc_sem_t ready;
    static QMutex lock;
    static bool busy = false;
    static bool active = false;

    /*****************************************************************************
     * Module callbacks
     *****************************************************************************/
    //modified by yulw,socket server for yingshitong
    static RCServer* pRemoteControl=NULL;
#ifdef Q_WS_MAC
    /* Used to abort the app.exec() on OSX after libvlc_Quit is called */
#include "../../../lib/libvlc_internal.h" /* libvlc_SetExitHandler */
static void Abort( void *obj )
{
    QVLCApp::triggerQuit();
}
#endif

static input_item_t *parse_MRL( const char *mrl )
{
#define SKIPSPACE( p ) { while( *p == ' ' || *p == '\t' ) p++; }
#define SKIPTRAILINGSPACE( p, d ) \
    { char *e=d; while( e > p && (*(e-1)==' ' || *(e-1)=='\t') ){e--;*e=0;} }
    input_item_t *p_item = NULL;
    char *psz_item = NULL, *psz_item_mrl = NULL, *psz_orig, *psz_mrl;
    char **ppsz_options = NULL;
    int i, i_options = 0;

    if( !mrl ) return 0;

    psz_mrl = psz_orig = strdup( mrl );
    if( !psz_mrl )
        return NULL;
    while( *psz_mrl )
    {
        SKIPSPACE( psz_mrl );
        psz_item = psz_mrl;

        for( ; *psz_mrl; psz_mrl++ )
        {
            if( (*psz_mrl == ' ' || *psz_mrl == '\t') && psz_mrl[1] == ':' )
            {
                /* We have a complete item */
                break;
            }
            if( (*psz_mrl == ' ' || *psz_mrl == '\t') &&
                    (psz_mrl[1] == '"' || psz_mrl[1] == '\'') && psz_mrl[2] == ':')
            {
                /* We have a complete item */
                break;
            }
        }

        if( *psz_mrl ) { *psz_mrl = 0; psz_mrl++; }
        SKIPTRAILINGSPACE( psz_item, psz_item + strlen( psz_item ) );

        /* Remove '"' and '\'' if necessary */
        if( *psz_item == '"' && psz_item[strlen(psz_item)-1] == '"' )
        { 
            psz_item++; psz_item[strlen(psz_item)-1] = 0; 
        }
        if( *psz_item == '\'' && psz_item[strlen(psz_item)-1] == '\'' )
        { 
            psz_item++; psz_item[strlen(psz_item)-1] = 0; 
        }

        if( !psz_item_mrl )
        {
            psz_item_mrl = make_URI( psz_item, NULL );
            if( !psz_item_mrl )
            {
                free( psz_orig );
                return NULL;
            }
        }
        else if( *psz_item )
        {
            i_options++;
            ppsz_options = (char**)xrealloc( ppsz_options, i_options * sizeof(char *) );
            ppsz_options[i_options - 1] = &psz_item[1];
        }

        if( *psz_mrl ) SKIPSPACE( psz_mrl );
    }

    /* Now create a playlist item */
    if( psz_item_mrl )
    {
        logger::inst()->log(TAG_INFO,"opening mrl:[%s]\n",psz_item_mrl);
        p_item = input_item_New( psz_item_mrl, NULL );
        for( i = 0; i < i_options; i++ )
        {
            input_item_AddOption( p_item, ppsz_options[i], VLC_INPUT_OPTION_TRUSTED );
        }
        free( psz_item_mrl );
    }

    if( i_options ) free( ppsz_options );
    free( psz_orig );

    return p_item;
}
int parseList(string src,std::vector<string>& dst) {
    int n=src.length();
    int i=0;
    while(i<n) {
        if(src[i]=='{') {
            int j=i+1;
            while(j<n&&src[j]!='}')
                j++;
            //missing closing bracket '}'
            if(src[j]!='}')
                return 1;
            dst.push_back(src.substr(i+1,j-i-1));
            i=j+1;
        }
        else
            i++;
    }
    return 0;
}
char* addItem(const char* item,char* dst) {
    if(!item)
        return NULL;
    int len=strlen(item);
    char* p=dst;
    if(!(p+len+1))
        return NULL;
    *(p++)='{';
    memcpy(p,item,len);
    p+=len;
    *(p++)='}';
    return p;
}
void info(const vlc_object_t* obj) {
    if(!obj)
        return;
    const char* prefix="TRACE:";
    logger::inst()->log(TAG_INFO,"%s ",prefix);
    if(obj->psz_object_type)
        logger::inst()->log(TAG_INFO,"[type:%s]",obj->psz_object_type);
    if(obj->psz_header)
        logger::inst()->log(TAG_INFO,"[header:%s]",obj->psz_header);
    logger::inst()->log(TAG_INFO,"[%s:%d]\n","flags",obj->i_flags);
}
void trace(const vlc_object_t* obj) {
    const vlc_object_t* p=obj;
    while(p) {
        info(p);
        p=p->p_parent;
    }
}
int getObject(vlc_object_t* object,const char* psz_variable,vlc_value_t& val,vlc_value_t& text,int& i_value,int option) {
    if ( var_Get( object, psz_variable, &val ) < 0 ) {
        vlc_object_release( object);
        return VLC_EGENERIC;
    }
    i_value = val.i_int;
    if ( var_Change(object , psz_variable, option, &val, &text ) < 0 ) {
        vlc_object_release(object);
        return VLC_EGENERIC;
    }
    return VLC_SUCCESS;
}
const char* getTrack(const char* psz_cmd) {
    if (strstr(psz_cmd, "ATrack")!=NULL) {
        return "audio-es";
    }
    else if (strstr(psz_cmd, "VTrack")!=NULL) {
        return "video-es";
    }
    else if(strstr(psz_cmd,"STrack")!=NULL){
        return "spu-es";
    }
    else
        return "Error";
}
//get all devices for current audiooutput
char* getAudioOutputDevicesList(vlc_object_t* p_aout,const char* psz_audio_output,char* result) 
{
    char *psz_config_name;
    char* psz_encode_list=result;
    if( psz_audio_output&&asprintf( &psz_config_name, "%s-audio-device", psz_audio_output ) != -1 ) 
    {
        module_config_t *p_module_config = config_FindConfig( VLC_OBJECT( p_aout->p_libvlc), psz_config_name );
        if( p_module_config )
        {
            if( p_module_config->i_list < 2 && p_module_config->pf_update_list )
            {
                vlc_value_t val;
                val.psz_string = strdup( p_module_config->value.psz );

                p_module_config->pf_update_list(
                        VLC_OBJECT( p_aout->p_libvlc), psz_config_name, val, val, NULL );
                free( val.psz_string );
            }
            logger::inst()->log(TAG_INFO,"[AudioOutput:%s]\n",psz_config_name);
            if(p_module_config->i_list ) {
                for(int i=0;i<p_module_config->i_list;i++) {
                    char* option_list_text=strdup(p_module_config->ppsz_list_text[i]);
                    char* option_list=strdup(p_module_config->ppsz_list[i]);
                    char* option=option_list?option_list:option_list_text;
                    if(!option)
                        continue;
                    psz_encode_list=addItem(option,psz_encode_list);
                    if(!psz_encode_list) {
                        logger::inst()->log(TAG_INFO,"Error in get audio out device for[%s]\n",option);
                        break;
                    }
                    logger::inst()->log(TAG_INFO,"---------------%s\n",option);
                }
            }
        }
        free( psz_config_name );
    }
    else
        logger::inst()->log(TAG_INFO,"[%s] not found\n",psz_config_name);
    return psz_encode_list;
}
//get all devices for current audiooutput
char* getAudioOutputList(vlc_object_t* p_aout,char* result)
{
    memset(result,0,sizeof(result));
    char* p=result;
    module_t **module_list = module_list_get( NULL );
    for (size_t i = 0; module_list[i]; i++)
    {
        module_t *p_module = module_list[i];

        if( module_provides( p_module, "audio output" ) )
        {
            char* psz_name= strdup( module_get_object( p_module ) ); char* psz_description= strdup( module_get_name( p_module, true )  );
            if(psz_name) {
                if(p!=NULL)
                    (*p++)='{';
                if(p+strlen(psz_name)) {
                    memcpy(p,psz_name,strlen(psz_name));
                    p+=strlen(psz_name);
                }
                if(p!=NULL)
                    (*p++)='}';
                logger::inst()->log(TAG_INFO,"AudioOutput_NAME:%s\n",psz_name);
            }
            if(psz_description) {
                logger::inst()->log(TAG_INFO,"AudioOutput_DESC:%s\n",psz_description);
            }
        }
    }
    *(p)='\0';
    module_list_free( module_list );
    return p;
}
//psz_config_name could be "aout" or "$aout-audio-device"
char* getCurrentAudioOutput(vlc_object_t* p_aout,char* psz_config_name) {
    if(!p_aout)
        return NULL;
    module_config_t *p_module_config = config_FindConfig( VLC_OBJECT( p_aout->p_libvlc), psz_config_name );
    if(!p_module_config)
        return NULL;
    logger::inst()->log(TAG_DEBUG,"getCurrentAudioOutput.value\t %s\n",p_module_config->value.psz);
    return p_module_config->value.psz;
}
char* getCurrentAudioOutputDeviceList(vlc_object_t* p_aout,char* psz_name,char* result) {
    char* delimeter=strstr(psz_name,"_");
    char* p=result;
    if(delimeter&&(delimeter+1))
        return getAudioOutputDevicesList(p_aout,delimeter+1,p);
    return getAudioOutputDevicesList(p_aout,psz_name,p);
}
char* getCurrentAudioOutput(vlc_object_t* p_aout) {
    char* psz_aout_name=getCurrentAudioOutput(p_aout,"aout");
    if(!psz_aout_name)
        return NULL;
    char* delimeter=strstr(psz_aout_name,"_");
    char* device_config_name;
    if(delimeter&&(delimeter+1))
        asprintf(&device_config_name,"%s-audio-device",delimeter+1);
    else
        asprintf(&device_config_name,"%s-audio-device",psz_aout_name);
    char* device=getCurrentAudioOutput(p_aout,device_config_name);
    return device&&strlen(device)?device:psz_aout_name;
}
int setAudioOutput(intf_thread_t* p_intf, input_thread_t *p_input,vlc_object_t* p_aout,const rc_value_t& val) {
    int result=-1;
    int index=(int)val.f_float;
    if(index<0||index>=VAL_RC_CONFIG.audioConfigInfo.size())
        return VLC_EGENERIC;
    char* device_config_key=strdup(VAL_RC_CONFIG.audioConfigInfo[index].first.c_str());
    char* device_config_val=strdup(VAL_RC_CONFIG.audioConfigInfo[index].second.c_str());
    if(!strcmp(device_config_key,"aout")) {
        //this module doesn't have additional specific device 
        result=var_SetString( p_aout, device_config_key, device_config_val);
        config_PutPsz(VLC_OBJECT(p_intf),device_config_key,device_config_val);
    }
    else {
        char* temp;
        asprintf(&temp,"%s-audio-device",device_config_key);
        config_PutPsz(VLC_OBJECT(p_intf),temp,device_config_val);
        free(temp);
        asprintf(&temp,"aout_%s",device_config_key);
        result=var_SetString( p_aout, "aout", temp);
        config_PutPsz(VLC_OBJECT(p_intf),"aout", temp);
        free(temp);
    }
    free(device_config_key);
    free(device_config_val);
    return result>=0?VLC_SUCCESS:VLC_EGENERIC;
}
int setAudioOutputOld(intf_thread_t* p_intf, input_thread_t *p_input,vlc_object_t* p_aout,const rc_value_t& val) {
    int result;
    result=var_SetString( p_aout, "aout", val.psz_string);
    config_PutPsz(VLC_OBJECT(p_intf),"aout",val.psz_string);
    return result;
}
const char* getAudioConf(const char* psz_cmd) {
    if (strstr(psz_cmd, "AudioDevice")!=NULL) {
        return  "audio-device";
    }
    else if (strstr(psz_cmd, "AudioChannels")!=NULL) {
        return "audio-channels";
    }
    else
        return "Error";
}
const char* getTrackTextValueByIndex(const vlc_value_t& val,const vlc_value_t& text,int index) {
    for(int i=0;i<val.p_list->i_count;i++) {
        if(!text.p_list->p_values[i].psz_string||*(text.p_list->p_values[i].psz_string)=='\0')
            continue;
        if(index==val.p_list->p_values[i].i_int) {
            return text.p_list->p_values[i].psz_string;
        }
    }
    return "NotFound";
}
struct TrackListCmp{
    bool operator()(const pair<int,string>& lh,const pair<int,string>& rh) {
        return lh.first<rh.first;
    }
};
const char* getTotalTrackList(const vlc_value_t&val,const vlc_value_t& text,char* result) {
    memset(result,0,MAX_SIZE);
    char* p=result;
    char temp[1000];
    int len;
    vector<pair<int,string> > track;
    for(int i=0;i<val.p_list->i_count;i++) {
        if(!text.p_list->p_values[i].psz_string||!strlen(text.p_list->p_values[i].psz_string))
            continue;
        memset(temp,0,sizeof(temp));
        len=strlen(text.p_list->p_values[i].psz_string);
        memcpy(temp,text.p_list->p_values[i].psz_string,len);
        track.push_back(std::make_pair(text.p_list->p_values[i].i_int+1,temp));
    }
    sort(track.begin(),track.end(),TrackListCmp());
    for(vector<pair<int,string> >::iterator iter=track.begin();iter!=track.end();iter++)
        p=addItem(const_cast<char*>(iter->second.c_str()),p);
    if(p==result)
        p=addItem("{}",p);
    *(p++)='\0';
    return result;
}
int getCurrentPlayListItemId(playlist_t *p_playlist) {
    if(!p_playlist)
        return -1;
    return p_playlist->i_current_index;
}
playlist_item_t* getCurrentPlayListItem(playlist_t *p_playlist) {
    int id=getCurrentPlayListItemId(p_playlist);
    if(id==-1)
        return NULL;
    return p_playlist->items.p_elems[id];
}
char* getCurrentPlayListItemName(playlist_t *p_playlist) {
    playlist_item_t* p_item=getCurrentPlayListItem(p_playlist);
    if(!p_item)
        return NULL;
    return p_item->p_input->psz_name;
}
char* getTotalPlayList(playlist_item_t *p_item, int i_level,char* result)
{
    memset(result,0,MAX_SIZE);
    char* p=result;
    for( int i = 0; i< p_item->i_children; i++ )
    {
        if(!p_item->pp_children[i]->p_input->psz_name||!strlen(p_item->pp_children[i]->p_input->psz_name))
            continue;
        p=addItem(p_item->pp_children[i]->p_input->psz_name,p);
        if( p_item->pp_children[i]->i_children >= 0 ) {
            char sublist[MAX_SIZE];
            char* q=sublist;
            q=getTotalPlayList(p_item->pp_children[i], i_level + 1,q);
            if(q&&strcmp(q,"{}")) {
                memcpy(p,q,strlen(q));
                p+=strlen(q);
            }
        }
    }
    if(p==result)
        p=addItem("{}",p);
    *(p++)='\0';
    return result;
}
static int AudioConfig(intf_thread_t* p_intf, input_thread_t *p_input, char const *psz_cmd,rc_value_t newval, char* p_data )
{
    const char * psz_variable;
    vlc_value_t val_name;
    int i_error;

    if( !p_input ) {
        i_error = VLC_ENOOBJ;
        ENCODE_MSG(p_data,i_error);
        return i_error;
    }
    int state = var_GetInteger( p_input, "state" );
    if( state == PAUSE_S )
    {
        //msg_rc( "%s", _("Type 'menu select' or 'pause' to continue.") );
        i_error = VLC_EGENERIC;
        ENCODE_MSG(p_data,i_error);
        return i_error;
    }

    vlc_object_t * p_aout = (vlc_object_t *)input_GetAout( p_input );
    vlc_object_release( p_input );
    if ( p_aout == NULL ) {
        i_error = VLC_ENOOBJ;
        ENCODE_MSG(p_data,i_error);
        return i_error;
    }
    psz_variable=getAudioConf(psz_cmd);
    /* Get the descriptive name of the variable */
    var_Change( p_aout, psz_variable, VLC_VAR_GETTEXT, &val_name, NULL );
    if( !val_name.psz_string ) 
        val_name.psz_string = strdup(psz_variable);
    int i_value;
    vlc_value_t val, text;
    if(strstr(psz_cmd,"AudioChannels")) {
        const char* audioDeviceVariable=getAudioConf("getAudioDevice");
        i_error=getObject(p_aout,audioDeviceVariable,val,text,i_value,VLC_VAR_GETCHOICES);
        if(i_error!=VLC_SUCCESS||i_value!=AOUT_VAR_STEREO) {
            i_error=VLC_EGENERIC;
            //make sure AudioDevice is Stereo when using Get/SetAudioChannels.@yulw
            if(strstr(psz_cmd,"All")) {
                ENCODE_MSG_WITH_RETURN(p_data,"%s","{}");
            }
            else if(strstr(psz_cmd,"get")) {
                ENCODE_MSG_WITH_RETURN(p_data,"%s","{}");
            }
            else if(strstr(psz_cmd,"set")) {
                ENCODE_MSG(p_data,i_error);
            }
            return i_error;
        }
    }
    if(
            !strcmp(psz_cmd,"getAudioDevice")||
            !strcmp(psz_cmd,"getAudioChannels")||
            !strcmp(psz_cmd,"getAudioDeviceText")||
            !strcmp(psz_cmd,"getAudioChannelsText")||
            !strcmp(psz_cmd,"getAllAudioDevice")|| 
            !strcmp(psz_cmd,"getAllAudioChannels")
      ) 
    {
        i_error=getObject(p_aout,psz_variable,val,text,i_value,VLC_VAR_GETCHOICES);
        if(i_error!=VLC_SUCCESS) {
            free( val_name.psz_string );
            i_error = VLC_EGENERIC;
            ENCODE_MSG(p_data,i_error);
            return i_error;
        }
        //if ( !*newval.psz_string)
        if (strstr(psz_cmd,"All")!=NULL) {
            //GetAllLists
            /* Retrieve all registered ***. */
            const char* totalTrackList=getTotalTrackList(val,text,p_data);
            ENCODE_MSG_WITH_RETURN(p_data,"%s",totalTrackList);
        }
        else {
            if(strstr(psz_cmd,"Text")!=NULL) {
                ENCODE_MSG_WITH_RETURN(p_data, "%s", getTrackTextValueByIndex(val,text,i_value));
            }
            else
                ENCODE_MSG_WITH_RETURN(p_data, "%d", i_value);
        }
        i_error = VLC_SUCCESS;
        var_FreeList( &val, &text );
    } 
    else if( !strcmp(psz_cmd,"setAudioDevice")||
            !strcmp(psz_cmd,"setAudioChannels")) 
    {
        //Set
        vlc_value_t val;
        val.i_int = atoi( newval.psz_string );
        i_error = var_Set( p_aout, psz_variable, val );
        ENCODE_MSG(p_data,i_error);
    }
    free( val_name.psz_string );
    vlc_object_release( p_aout );
    return i_error;
}

static int Input(intf_thread_t* p_intf, input_thread_t *p_input, char const *psz_cmd, rc_value_t newval, char* p_data) {

    int result = VLC_EGENERIC;
    playlist_t *p_playlist = pl_Get(p_intf);
    vlc_value_t val = { 0 };
    char buf[30];


    if (!p_input || p_input->b_dead)
    { 
        if ((!strcmp(psz_cmd, "setAdd")||!strcmp(psz_cmd, "setOpen"))&&newval.psz_string&&*newval.psz_string)
        {
            const char* mrl=RCPlayListModel::inst()->handle(newval.psz_string);
            input_item_t *p_item = parse_MRL(mrl);
            if (p_item) {
                result = playlist_AddInput(p_playlist, p_item, PLAYLIST_GO | PLAYLIST_APPEND, PLAYLIST_END, true, pl_Unlocked);
                vlc_gc_decref(p_item);
            }
            else
                result=VLC_ENOOBJ;
            ENCODE_MSG(p_data, result);
        }
        else {
            result=VLC_ENOOBJ;
            ENCODE_MSG_WITH_RETURN(p_data, "%s","Add or ReOpen a File First");
        }
        return result;

    }
    else
    {

        int state = var_GetInteger(p_input, "state");
        /*
           if ((state != PLAYING_S) &&strcmp(psz_cmd, "play")&&strcmp(psz_cmd, "frame")&&strncmp(psz_cmd, "get",3)) {
           ENCODE_MSG_WITH_RETURN(p_data, "%s", "Only 'Set' or 'Play' operation is allowed.");
           }
           else 
           */
        if (!strcmp(psz_cmd, "getState"))
        {

            switch (state)
            {
                case INIT_S:

                    ENCODE_MSG_WITH_RETURN(p_data, "%s", "init");

                    break;
                case OPENING_S:

                    ENCODE_MSG_WITH_RETURN(p_data, "%s", "openning");

                    break;
                case PLAYING_S:

                    ENCODE_MSG_WITH_RETURN(p_data, "%s", "playing");

                    break;
                case PAUSE_S:
                    ENCODE_MSG_WITH_RETURN(p_data, "%s", "pausing");


                    break;
                case END_S:
                    ENCODE_MSG_WITH_RETURN(p_data, "%s", "ending");

                    break;
                case ERROR_S:
                    ENCODE_MSG_WITH_RETURN(p_data, "%s", "error");
                    break;
            }
            result = VLC_SUCCESS;
        }
        else if (!strcmp(psz_cmd, "getLength"))
        {
            int64_t i_64 = var_GetTime(p_input, "length");

            ENCODE_MSG_WITH_RETURN(p_data, "%d", i_64/1000);

            result = VLC_SUCCESS;

        }
        else if (!strcmp(psz_cmd, "getTime"))
        {
            int64_t i_64 = var_GetTime(p_input, "time");

            ENCODE_MSG_WITH_RETURN(p_data, "%d", i_64 / 1000);
            result = VLC_SUCCESS;

        }
        else if (!strcmp(psz_cmd, "play"))
        {


            if (state == PAUSE_S)
                result = var_SetInteger(p_input, "state", PLAYING_S);

            else if (state == PLAYING_S)
                result = var_SetInteger(p_input, "state", PAUSE_S);
            else {
                result = playlist_Play(p_playlist);
            }
            ENCODE_MSG(p_data, result);
        }
        else if (!strcmp(psz_cmd, "getPosition"))
        {
            float f = var_GetFloat(p_input, "position");

            ENCODE_MSG_WITH_RETURN(p_data, "%f", f);
        }
        else if (!strcmp(psz_cmd, "setPosition"))
        {

            if (newval.b_bool)
            {

                result = var_SetFloat(p_input, "position", newval.f_float);
            }

            ENCODE_MSG(p_data, result);


        }
        else if (!strcmp(psz_cmd, "forward"))
        {
            float ff = var_GetFloat(p_input, "position");
            result = var_SetFloat(p_input, "position", ff + 0.02 > 1.0 ? 1.0 : ff + 0.02);

            ENCODE_MSG(p_data, result);

        }
        else if (!strcmp(psz_cmd, "backward"))
        {
            float ff = var_GetFloat(p_input, "position");
            result = var_SetFloat(p_input, "position", ff - 0.02<1.0 ? 0.0 : ff - 0.02);

            ENCODE_MSG(p_data, result);

        }
        else if (!strcmp(psz_cmd, "faster"))
        {
            float f = var_GetFloat(p_input, "rate");
            f = (f < 0) ? -f : f * 2;
            result = var_SetFloat(p_input, "rate", f);

            ENCODE_MSG(p_data, result);

        }
        else if (!strcmp(psz_cmd, "slower"))
        {
            float f = var_GetFloat(p_input, "rate");
            f = (f>0) ? -f : -0.5*f;
            result = var_SetFloat(p_input, "rate", f);

            ENCODE_MSG(p_data, result);

        }
        else if (!strcmp(psz_cmd, "normal"))
        {
            result = var_SetFloat(p_input, "rate", 1.0);
            ENCODE_MSG(p_data, result);

        }
        else if (!strcmp(psz_cmd, "frame"))
        {
            result = var_TriggerCallback(p_input, "frame-next");
            ENCODE_MSG(p_data, result);

        }
        else if (!strcmp(psz_cmd, "getVolume"))
        {
            audio_volume_t volume= aout_VolumeGet(pl_Get(p_intf));
            float f= ((int)volume)/(float)AOUT_VOLUME_MAX;
            //ENCODE_MSG_WITH_RETURN(p_data, "%d:%f", volume,f);
            ENCODE_MSG_WITH_RETURN(p_data, "%f",f);
        }
        else if (!strcmp(psz_cmd, "volumeup")||!strcmp(psz_cmd,"volumedown")) {
            playlist_t* playlist = pl_Get(p_intf);
            audio_volume_t i_volume;
            int i_nb_steps=1;
            if(newval.b_bool)
                i_nb_steps=(int)newval.f_float;
            if(!strcmp(psz_cmd,"volumedown"))
                i_nb_steps*=-1;
            result=aout_VolumeUp(playlist, i_nb_steps, &i_volume );
            ENCODE_MSG(p_data, result);
        }
        else if (!strcmp(psz_cmd, "setVolume"))
        {
            playlist_t* playlist = pl_Get(p_intf);
            if (newval.b_bool) {
                result = aout_VolumeSet(playlist, newval.f_float*AOUT_VOLUME_MAX);
            }
            ENCODE_MSG(p_data, result);
        }
        else if (!strcmp(psz_cmd, "getMute"))
        {
            playlist_t* playlist = pl_Get(p_intf);
            int i_isMuted=aout_IsMuted(VLC_OBJECT(playlist));
            ENCODE_MSG_WITH_RETURN(p_data, "%d", i_isMuted);
        }
        else if (!strcmp(psz_cmd, "mute"))
        {
            playlist_t* playlist = pl_Get(p_intf);
            //modified in 15.11.18
            result=aout_ToggleMute(playlist,NULL);
            ENCODE_MSG(p_data, result);
        }
        else if (!strcmp(psz_cmd, "getChapter"))
        {

            int i_chap = var_GetInteger(p_input, "chapter");
            int i_chapter_count = var_CountChoices(p_input, "chapter");
            ENCODE_MSG_WITH_RETURN(p_data, "%d", i_chap);

        }
        else if (!strcmp(psz_cmd, "setChapter"))
        {
            if (newval.b_bool) {
                result = var_SetInteger(p_input, "chapter", (int)newval.f_float);
            }

            ENCODE_MSG(p_data, result);


        }
        else if (!strcmp(psz_cmd, "chapter_n") || !strcmp(psz_cmd, "chapter_p"))
        {
            if (!strcmp(psz_cmd, "chapter_n"))
                result = var_TriggerCallback(p_input, "next-chapter");
            else if (!strcmp(psz_cmd, "chapter_p"))
                result = var_TriggerCallback(p_input, "prev-chapter");

            ENCODE_MSG(p_data, result);

        }
        else if (!strcmp(psz_cmd, "getTitle") ||
                !strcmp(psz_cmd, "setTitle") ||
                !strcmp(psz_cmd, "title_n") ||
                !strcmp(psz_cmd, "title_p"))
        {
            if (!strcmp(psz_cmd, "getTitle"))
            {
                /* Get. */
                int i_title = var_GetInteger(p_input, "title");
                int i_title_count = var_CountChoices(p_input, "title");
                ENCODE_MSG_WITH_RETURN(p_data, "Currently playing title %d/%d.", i_title, i_title_count);
            }
            else {
                if(!strcmp(psz_cmd,"setTitle")){
                    if (*newval.psz_string)
                        /* Set. */
                        result = var_SetInteger(p_input, "title", atoi(newval.psz_string));
                }
                else if (!strcmp(psz_cmd, "title_n"))
                    result = var_TriggerCallback(p_input, "next-title");
                else if (!strcmp(psz_cmd, "title_p"))
                    result = var_TriggerCallback(p_input, "prev-title");
                ENCODE_MSG(p_data,result);
            }
        }
        else if(!strcmp(psz_cmd,"getAllPlayList")||
                !strcmp(psz_cmd,"getAllSTrack")||
                !strcmp(psz_cmd,"getAllATrack")||
                !strcmp(psz_cmd,"getAllVTrack")||
                !strcmp(psz_cmd,"getAllSTrack")
               ) 
        {
            if(strstr(psz_cmd,"Track")!=NULL) {
                const char* psz_variable=getTrack(psz_cmd);
                vlc_value_t val, text,val_name;
                var_Change(p_input, psz_variable, VLC_VAR_GETTEXT, &val_name, NULL);
                result=var_Get(p_input, psz_variable, &val);
                if(result>=0) {
                    var_Change(p_input, psz_variable, VLC_VAR_GETLIST, &val, &text);
                    const char* totalTrackList=getTotalTrackList(val,text,p_data);
                    ENCODE_MSG_WITH_RETURN(p_data,"%s",totalTrackList);
                }
                else
                    ENCODE_MSG_WITH_RETURN(p_data, "%s", "{}");
                var_FreeList(&val, &text);
            }
            else if(strstr(psz_cmd,"PlayList")!=NULL) {

            }
        }
        else if (!strcmp(psz_cmd, "getATrack") || 
                !strcmp(psz_cmd, "getVTrack") || 
                !strcmp(psz_cmd, "getSTrack") || 
                !strcmp(psz_cmd, "setATrack") || 
                !strcmp(psz_cmd, "setVTrack") || 
                !strcmp(psz_cmd, "setSTrack") || 
                !strcmp(psz_cmd, "getATrackText") || 
                !strcmp(psz_cmd, "getVTrackText") || 
                !strcmp(psz_cmd, "getSTrackText"))
        {
            logger::inst()->log(TAG_DEBUG,"[INPUT]:%s\n",psz_cmd);
            const char *psz_variable=getTrack(psz_cmd);
            vlc_value_t val_name;
            /* Get the descriptive name of the variable */
            var_Change(p_input, psz_variable, VLC_VAR_GETTEXT, &val_name, NULL);
            if (!val_name.psz_string)
                val_name.psz_string = strdup(psz_variable);
            if (newval.psz_string && *newval.psz_string && strstr(psz_cmd,"set")!=NULL) {
                logger::inst()->log(TAG_DEBUG,"[INPUT]:%s set\n",psz_variable);
                /* set */
                result = var_SetInteger(p_input, psz_variable, atoi(newval.psz_string));

                ENCODE_MSG(p_data, result);

            }
            else
            {
                /* get */
                logger::inst()->log(TAG_DEBUG,"[INPUT]:%s get\n",psz_variable);
                vlc_value_t val, text;
                int i, i_value;
                if (var_Get(p_input, psz_variable, &val)< 0) {
                    logger::inst()->log(TAG_DEBUG,"[INPUT]:%s\n: failed to call ::val_Get.",psz_variable);
                    result = VLC_EGENERIC;
                    ENCODE_MSG(p_data, result);
                }
                else {
                    i_value = val.i_int;
                    if (var_Change(p_input, psz_variable, VLC_VAR_GETLIST, &val, &text) < 0) {
                        logger::inst()->log(TAG_DEBUG,"[INPUT]:%s\n: failed to call ::var_Change using VLC_VAR_GETLIST.",psz_variable);
                        result = VLC_EGENERIC;
                        ENCODE_MSG(p_data, result);
                    }
                    else {
                        if(strstr(psz_cmd,"Text")!=NULL) {
                            ENCODE_MSG_WITH_RETURN(p_data, "%s", getTrackTextValueByIndex(val,text,i_value));
                        }
                        else
                            ENCODE_MSG_WITH_RETURN(p_data, "%d", i_value);
                        logger::inst()->log(TAG_DEBUG,"[INPUT]:Successed.Result:%s\n",p_data);
                        var_FreeList(&val, &text);
                    }
                }
            }
            free(val_name.psz_string);
        }
        else if(strstr(psz_cmd,"AudioDevice")!=NULL ||
                strstr(psz_cmd,"AudioChannels")!=NULL) {
            //Audio Config
            result=AudioConfig(p_intf,p_input,psz_cmd,newval,p_data);
        }
        else if(!strcmp(psz_cmd,"getAudioOutput")||
                !strcmp(psz_cmd,"setAudioOutput")||
                !strcmp(psz_cmd,"getAllAudioOutput"))
        {
            vlc_object_t * p_aout = (vlc_object_t *)input_GetAout( p_input );
            vlc_object_release( p_input );
            if ( p_aout == NULL ) {
                result= VLC_ENOOBJ;
                ENCODE_MSG(p_data,result);
            }
            else {
                if(strstr(psz_cmd,"get")) {
                    if(strstr(psz_cmd,"All")) {
                        char temp[MAX_SIZE];
                        getAudioOutputList(p_aout,temp);
                        ENCODE_MSG_WITH_RETURN(p_data,"%s",temp);
                    }
                    else {
                        char* aoutput=strdup(getCurrentAudioOutput(p_aout));
                        ENCODE_MSG_WITH_RETURN(p_data,"%s",aoutput);
                    }
                }
                else if(strstr(psz_cmd,"set")) {
                    result=setAudioOutput(p_intf,p_input,p_aout,newval);
                    ENCODE_MSG(p_data,result);
                }
                vlc_object_release( p_aout );
            }

        }
        else if (!strcmp(psz_cmd, "prev")) {
            result = playlist_Prev(p_playlist);
            ENCODE_MSG(p_data, result);
        }
        else if (!strcmp(psz_cmd, "next")) {
            result = playlist_Next(p_playlist);

            ENCODE_MSG(p_data, result);
        }
        else if (!strcmp(psz_cmd, "repeat"))
        {
            bool b_update = true;

            var_Get(p_playlist, "repeat", &val);

            if (strlen(newval.psz_string) > 0)
            {
                if ((!strncmp(newval.psz_string, "on", 2) && val.b_bool) ||
                        (!strncmp(newval.psz_string, "off", 3) && !val.b_bool))
                {
                    b_update = false;
                }
            }

            if (b_update)
            {
                val.b_bool = !val.b_bool;
                result = var_Set(p_playlist, "repeat", val);

            }
            else
                result = VLC_EGENERIC;
            ENCODE_MSG(p_data, result);

        }
        else if (!strcmp(psz_cmd, "loop"))
        {
            bool b_update = true;

            var_Get(p_playlist, "loop", &val);

            if (strlen(newval.psz_string) > 0)
            {
                if ((!strncmp(newval.psz_string, "on", 2) && val.b_bool) ||
                        (!strncmp(newval.psz_string, "off", 3) && !val.b_bool))
                {
                    b_update = false;
                }
            }

            if (b_update)
            {
                val.b_bool = !val.b_bool;
                result = var_Set(p_playlist, "loop", val);
            }
            else
                result = VLC_EGENERIC;
            ENCODE_MSG(p_data, result);

        }
        else if (!strcmp(psz_cmd, "random"))
        {
            bool b_update = true;

            var_Get(p_playlist, "random", &val);

            if (strlen(newval.psz_string) > 0)
            {
                if ((!strncmp(newval.psz_string, "on", 2) && val.b_bool) ||
                        (!strncmp(newval.psz_string, "off", 3) && !val.b_bool))
                {
                    b_update = false;
                }
            }

            if (b_update)
            {
                val.b_bool = !val.b_bool;
                result = var_Set(p_playlist, "random", val);

            }
            else
                result = VLC_EGENERIC;
            ENCODE_MSG(p_data, result);

        }
        else if (!strcmp(psz_cmd, "setPlayListItem"))
        {
            PL_LOCK;
            unsigned i_pos = atoi(newval.psz_string);
            unsigned i_size = p_playlist->items.i_size;

            if (i_pos > 0 && i_pos <= i_size)
            {
                playlist_item_t *p_item, *p_parent;
                p_item = p_parent = p_playlist->items.p_elems[i_pos];
                while (p_parent->p_parent)
                    p_parent = p_parent->p_parent;
                result = playlist_Control(p_playlist, PLAYLIST_VIEWPLAY, pl_Locked, p_parent, p_item);
            }

            PL_UNLOCK;
            ENCODE_MSG(p_data, result);
        }
        else if(!strcmp(psz_cmd,"getPlayListItem")) {
            //get the id of the item that is being played.
            PL_LOCK; 
            int i_current_index=p_playlist->i_current_index;
            ENCODE_MSG_WITH_RETURN(p_data,"%d",i_current_index);
            PL_UNLOCK;
        }
        else if(!strcmp(psz_cmd,"getPlayListItemName")) {
            //get the id of the item that is being played.
            PL_LOCK; 
            char* name=getCurrentPlayListItemName(p_playlist);
            ENCODE_MSG_WITH_RETURN(p_data,"%s",name);
            PL_UNLOCK;
        }
        else if(!strcmp(psz_cmd,"getPlayListItemId")) {
            //get the id of the item that is being played.
            PL_LOCK; 
            char* name=getCurrentPlayListItemName(p_playlist);
            const char* id=RCPlayListModel::inst()->getID(name);
            ENCODE_MSG_WITH_RETURN(p_data,"%s",id?id:"-1");
            PL_UNLOCK;
        }
        else if (!strcmp(psz_cmd, "stop"))
        {
            result = playlist_Stop(p_playlist);

            ENCODE_MSG(p_data, result);
        }
        else if (!strcmp(psz_cmd, "clear"))
        {
            playlist_Clear(p_playlist, pl_Unlocked);
            ENCODE_MSG(p_data, result);
        }
        else if (!strcmp(psz_cmd, "setAdd") &&
                newval.psz_string && *newval.psz_string)
        {
            const char* mrl=RCPlayListModel::inst()->handle(newval.psz_string);
            input_item_t *p_item = parse_MRL(mrl);

            if (p_item)
            {
                result = playlist_AddInput(p_playlist, p_item,
                        PLAYLIST_GO | PLAYLIST_APPEND, PLAYLIST_END, true,
                        pl_Unlocked);
                vlc_gc_decref(p_item);
            }
            ENCODE_MSG(p_data, result);

        }
        else if (!strcmp(psz_cmd, "setEnqueue") &&
                newval.psz_string && *newval.psz_string)
        {
            input_item_t *p_item = parse_MRL(newval.psz_string);

            if (p_item)
            {
                sprintf(p_data, "trying to enqueue %s to playlist", newval.psz_string);
                result = playlist_AddInput(p_playlist, p_item, PLAYLIST_APPEND, PLAYLIST_END, true, pl_Unlocked);
            }
            ENCODE_MSG(p_data, result);

        }
        else if (!strcmp(psz_cmd, "getPlayList")) {
            playlist_item_t* item=p_playlist->p_root_category;
            char* tail=getTotalPlayList(item,0,p_data);
            tail='\0';
        }
        else if (!strcmp(psz_cmd, "sort")) {
            PL_LOCK;
            result = playlist_RecursiveNodeSort(p_playlist, p_playlist->p_root_onelevel,
                    SORT_ARTIST, ORDER_NORMAL);

            PL_UNLOCK;
            ENCODE_MSG(p_data, result);

        }
        else {
            ENCODE_MSG_WITH_RETURN(p_data, "%s", "unknown command");
        }

        return result;

    }

}
static void RegisterIntf( vlc_object_t *p_this )
{
    playlist_t *pl = pl_Get(p_this);
    var_Create (pl, "qt4-iface", VLC_VAR_ADDRESS);
    var_SetAddress (pl, "qt4-iface", p_this);
    var_Create (pl, "window", VLC_VAR_STRING);
    var_SetString (pl, "window", "qt4,any");
}

/* Open Interface */
static int Open( vlc_object_t *p_this, bool isDialogProvider )
{
    intf_thread_t *p_intf = (intf_thread_t *)p_this;

#ifdef Q_WS_X11
    if( !vlc_xlib_init( p_this ) )
        return VLC_EGENERIC;

    Display *p_display = XOpenDisplay( NULL );
    if( !p_display )
    {
        msg_Err( p_intf, "Could not connect to X server" );
        return VLC_EGENERIC;
    }
    XCloseDisplay( p_display );
#endif

    QMutexLocker locker (&lock);
    if (busy)
    {
        msg_Err (p_this, "cannot start Qt4 multiple times");
        return VLC_EGENERIC;
    }

    /* Allocations of p_sys */
    intf_sys_t *p_sys = p_intf->p_sys = new intf_sys_t;
    p_intf->p_sys->b_isDialogProvider = isDialogProvider;
    p_sys->p_mi = NULL;
    p_sys->pl_model = NULL;

    /* */
    vlc_sem_init (&ready, 0);
#ifdef Q_WS_MAC
    /* Run mainloop on the main thread as Cocoa requires */
    libvlc_SetExitHandler( p_intf->p_libvlc, Abort, p_intf );
    Thread( (void *)p_intf );
#else
    if( vlc_clone( &p_sys->thread, Thread, p_intf, VLC_THREAD_PRIORITY_LOW ) )
    {
        delete p_sys;
        return VLC_ENOMEM;
    }
#endif

    /* Wait for the interface to be ready. This prevents the main
     * LibVLC thread from starting video playback before we can create
     * an embedded video window. */
    vlc_sem_wait (&ready);
    vlc_sem_destroy (&ready);
    busy = active = true;

#ifndef Q_WS_MAC
    if( !isDialogProvider )
    {
        RegisterIntf( p_this );
    }
#endif
    VAL_RC_CONFIG.port=VAL_RC_DEFAULT_PORT;
    VAL_RC_CONFIG.isDebug=0;
    logger::inst()->setDebug(1);
    logger::inst()->reset();
    SaveAudioOutputDevice(p_intf,VAL_RC_CONFIG,"./AudiooutputInfo.ini");
    readConfig(VAL_RC_CONFIG,"./config.ini");
    logger::inst()->log("%s\n","gui started.");
    pRemoteControl = new RCServer(p_intf);
    pRemoteControl->InitForPort(VAL_RC_CONFIG.port);
    logger::inst()->setDebug(1);
    pRemoteControl->start();
    return VLC_SUCCESS;
}

/* Open qt4 interface */
static int OpenIntf( vlc_object_t *p_this )
{
    return Open( p_this, false );
}

/* Open Dialog Provider */
static int OpenDialogs( vlc_object_t *p_this )
{
    return Open( p_this, true );
}

static void Close( vlc_object_t *p_this )
{
    intf_thread_t *p_intf = (intf_thread_t *)p_this;
    intf_sys_t *p_sys = p_intf->p_sys;

    if( !p_sys->b_isDialogProvider )
    {
        var_Destroy (pl_Get(p_this), "window");
        var_Destroy (pl_Get(p_this), "qt4-iface");
    }

    /* And quit */
    msg_Dbg( p_this, "requesting exit..." );
    QVLCApp::triggerQuit();

    msg_Dbg( p_this, "waiting for UI thread..." );
#ifndef Q_WS_MAC
    vlc_join (p_sys->thread, NULL);
#endif
    delete p_sys;

    QMutexLocker locker (&lock);
    assert (busy);
    busy = false;
}

static void *Thread( void *obj )
{
    intf_thread_t *p_intf = (intf_thread_t *)obj;
    MainInterface *p_mi;
    char dummy[] = "vlc"; /* for WM_CLASS */
    char *argv[2] = { dummy, NULL, };
    int argc = 1;

    Q_INIT_RESOURCE( vlc );

    /* Start the QApplication here */
    QVLCApp app( argc, argv );

    p_intf->p_sys->p_app = &app;


    /* All the settings are in the .conf/.ini style */
    p_intf->p_sys->mainSettings = new QSettings(
#ifdef WIN32
            QSettings::IniFormat,
#else
            QSettings::NativeFormat,
#endif
            QSettings::UserScope, "vlc", "vlc-qt-interface" );

    /* Icon setting, Mac uses icon from .icns */
#ifndef Q_WS_MAC
    if( QDate::currentDate().dayOfYear() >= QT_XMAS_JOKE_DAY && var_InheritBool( p_intf, "qt-icon-change" ) )
        app.setWindowIcon( QIcon(":/custome/logo") );
    else
        app.setWindowIcon( QIcon(":/custome/logo") );
#endif

    /* Initialize timers and the Dialog Provider */
    DialogsProvider::getInstance( p_intf );

    /* Detect screensize for small screens like TV or Netbooks */
    p_intf->p_sys->i_screenHeight =
        app.QApplication::desktop()->availableGeometry().height();

#ifdef UPDATE_CHECK
    /* Checking for VLC updates */
    if( var_InheritBool( p_intf, "qt-updates-notif" ) &&
            !var_InheritBool( p_intf, "qt-privacy-ask" ) )
    {
        int interval = var_InheritInteger( p_intf, "qt-updates-days" );
        if( QDate::currentDate() >
                getSettings()->value( "updatedate" ).toDate().addDays( interval ) )
        {
            /* The constructor of the update Dialog will do the 1st request */
            UpdateDialog::getInstance( p_intf );
            getSettings()->setValue( "updatedate", QDate::currentDate() );
        }
    }
#endif

    /* Create the normal interface in non-DP mode */
    if( !p_intf->p_sys->b_isDialogProvider )
    {
        p_mi = new MainInterface( p_intf );
        p_intf->p_sys->p_mi = p_mi;
    }
    else
        p_mi = NULL;

    /* Explain how to show a dialog :D */
    p_intf->pf_show_dialog = ShowDialog;

    /* Tell the main LibVLC thread we are ready */
    vlc_sem_post (&ready);

#ifdef Q_WS_MAC
    /* We took over main thread, register and start here */
    if( !p_intf->p_sys->b_isDialogProvider )
    {
        RegisterIntf( (vlc_object_t *)p_intf );
        playlist_Play( THEPL );
    }
#endif

    /* Last settings */
    app.setQuitOnLastWindowClosed( false );

    /* Retrieve last known path used in file browsing */
    p_intf->p_sys->filepath =
        getSettings()->value( "filedialog-path", QVLCUserDir( VLC_HOME_DIR ) ).toString();

    /* Loads and tries to apply the preferred QStyle */
    QString s_style = getSettings()->value( "MainWindow/QtStyle", "" ).toString();
    if( s_style.compare("") != 0 )
        QApplication::setStyle( s_style );

    /* Launch */
    app.exec();

    msg_Dbg( p_intf, "QApp exec() finished" );
    if (p_mi != NULL)
    {
        QMutexLocker locker (&lock);
        active = false;

        p_intf->p_sys->p_mi = NULL;
        /* Destroy first the main interface because it is connected to some
           slots in the MainInputManager */
        delete p_mi;
    }

    /* Destroy all remaining windows,
       because some are connected to some slots
       in the MainInputManager
       Settings must be destroyed after that.
       */
    DialogsProvider::killInstance();

    /* Delete the recentsMRL object before the configuration */
    RecentsMRL::killInstance();

    /* Save the path or delete if recent play are disabled */
    if( var_InheritBool( p_intf, "qt-recentplay" ) )
        getSettings()->setValue( "filedialog-path", p_intf->p_sys->filepath );
    else
        getSettings()->remove( "filedialog-path" );

    /* */
    delete p_intf->p_sys->pl_model;

    /* Delete the configuration. Application has to be deleted after that. */
    delete p_intf->p_sys->mainSettings;

    /* Destroy the MainInputManager */
    MainInputManager::killInstance();

    /* Delete the application automatically */
    return NULL;
}

/*****************************************************************************
 * Callback to show a dialog
 *****************************************************************************/
static void ShowDialog( intf_thread_t *p_intf, int i_dialog_event, int i_arg,
        intf_dialog_args_t *p_arg )
{
    VLC_UNUSED( p_intf );
    DialogEvent *event = new DialogEvent( i_dialog_event, i_arg, p_arg );
    QApplication::postEvent( THEDP, event );
}

/**
 * Video output window provider
 *
 * TODO move it out of here ?
 */
static int WindowControl( vout_window_t *, int i_query, va_list );

static int WindowOpen( vout_window_t *p_wnd, const vout_window_cfg_t *cfg )
{
    /* */
    if( cfg->is_standalone )
        return VLC_EGENERIC;
#if defined (Q_WS_X11)
    if( var_InheritBool( p_wnd, "video-wallpaper" ) )
        return VLC_EGENERIC;
#endif

    intf_thread_t *p_intf =
        (intf_thread_t *)var_InheritAddress( p_wnd, "qt4-iface" );
    if( !p_intf )
    {   /* If another interface is used, this plugin cannot work */
        msg_Dbg( p_wnd, "Qt4 interface not found" );
        return VLC_EGENERIC;
    }

    QMutexLocker locker (&lock);
    if (unlikely(!active))
        return VLC_EGENERIC;

    MainInterface *p_mi = p_intf->p_sys->p_mi;
    msg_Dbg( p_wnd, "requesting video..." );

    int i_x = cfg->x;
    int i_y = cfg->y;
    unsigned i_width = cfg->width;
    unsigned i_height = cfg->height;

#if defined (Q_WS_X11)
    p_wnd->handle.xid = p_mi->getVideo( &i_x, &i_y, &i_width, &i_height );
    if( !p_wnd->handle.xid )
        return VLC_EGENERIC;
    p_wnd->display.x11 = NULL;

#elif defined (Q_WS_WIN) || defined(Q_WS_PM)
    p_wnd->handle.hwnd = (void *)p_mi->getVideo( &i_x, &i_y, &i_width, &i_height );
    if( !p_wnd->handle.hwnd )
        return VLC_EGENERIC;

#elif defined (Q_WS_MAC)
    p_wnd->handle.nsobject = (void *)p_mi->getVideo( &i_x, &i_y, &i_width, &i_height );
    if( !p_wnd->handle.nsobject )
        return VLC_EGENERIC;
#else
# error FIXME
#endif

    p_wnd->control = WindowControl;
    p_wnd->sys = (vout_window_sys_t*)p_mi;
    return VLC_SUCCESS;
}

static int WindowControl( vout_window_t *p_wnd, int i_query, va_list args )
{
    MainInterface *p_mi = (MainInterface *)p_wnd->sys;
    QMutexLocker locker (&lock);

    if (unlikely(!active))
    {
        msg_Warn (p_wnd, "video already released before control");
        return VLC_EGENERIC;
    }
    return p_mi->controlVideo( i_query, args );
}

static void WindowClose( vout_window_t *p_wnd )
{
    MainInterface *p_mi = (MainInterface *)p_wnd->sys;
    QMutexLocker locker (&lock);

    /* Normally, the interface terminates after the video. In the contrary, the
     * Qt4 main loop is gone, so we cannot send any event to the user interface
     * widgets. Ideally, we would keep the Qt4 main loop running until after
     * the video window is released. But it is far simpler to just have the Qt4
     * thread destroy the window early, and to turn this function into a stub.
     *
     * That assumes the video output will behave sanely if it window is
     * destroyed asynchronously.
     * XCB and Xlib-XCB are fine with that. Plain Xlib wouldn't, */
    if (unlikely(!active))
    {
        msg_Warn (p_wnd, "video already released");
        return;
    }
    msg_Dbg (p_wnd, "releasing video...");
    p_mi->releaseVideo();
}
bool isNumber(const char* s) {
    if(!s||*(s)=='\0')
        return false;
    const char* p=s;
    while(!p||*(p)=='\0') {
        if(*(p)<='9'&&*(p)>='0'||*(p)=='.'||*(p)=='+'||*(p)=='-')
            p++;
        else
            return false;
    }
    return true;
}

bool parseMsg(char* msgRcv,rc_value_t& val)
{
    bool b_needProceed = true;
    char* delimiter = "#";
    char* valStr = strstr(msgRcv, delimiter);
    if (!strncmp(msgRcv, "set", 3))
    {
        if (valStr == NULL) {
            ENCODE_MSG_WITH_RETURN(msgRcv, "%s", "Use: [SettingCommand]#[Value]");
            b_needProceed = false;
        }
        else if (*(valStr + 1) == '\0') {
            ENCODE_MSG_WITH_RETURN(msgRcv, "%s", "Need to specify a value.");
            b_needProceed = false;
        }
    }
    /*
       we don't want commands with a prefix of "get",such as getATrack#1,etc,to be used.
       As the socket server has been extened,some new commands has been added and implemented.So items like volumeup#2 are accepetable.@yulw,15-11-21
       */
    if(valStr&&*(valStr+1)!='\0'&&strstr(msgRcv,"get")==NULL) {
        val.f_float = atof(valStr + 1);
        val.psz_string = valStr + 1;
        msgRcv[valStr - msgRcv] = '\0';

    }
    return b_needProceed;

}
void readConfig(RC_CONFIG& config,const char* file) {
    char buf[MAX_SIZE];
    const char* server_setting_section="ServerSetting";
    const char* port_key="Port";
    const char* isDebug_key="IsDebug";
    memset(buf,0,sizeof(buf));
    config.port=VAL_RC_DEFAULT_PORT;
    if(read_profile_string(server_setting_section,port_key,buf,MAX_SIZE,"",file)) {
        config.port=atoi(buf);
        logger::inst()->log(TAG_INFO,"port set to:%s\n",buf);
    }
    memset(buf,0,sizeof(buf));
    config.isDebug=0;
    if(read_profile_string(server_setting_section,isDebug_key,buf,MAX_SIZE,"",file))
        config.isDebug=atoi(buf);
    const char* audio_setting_section="AudioOutputSetting";
    const char* movie_audio_output_index_key="Movie";
    const char* ktv_audio_output_index_key="KTV";
    memset(buf,0,sizeof(buf));
    config.audioConfigMovieIndex=-1;
    if(read_profile_string(audio_setting_section,movie_audio_output_index_key,buf,MAX_SIZE,"",file)) {
        config.audioConfigMovieIndex=atoi(buf);
        if(config.audioConfigMovieIndex<0||config.audioConfigMovieIndex>=config.audioConfigInfo.size())
            logger::inst()->log(TAG_ERROR,"%s Error.\n","audioConfigMovieIndex");
        else
            logger::inst()->log(TAG_INFO,"MovieAudioOutput set to:%s\n",config.audioConfigInfo[config.audioConfigMovieIndex].second.c_str());
    }
    memset(buf,0,sizeof(buf));
    config.audioConfigKTVIndex=-1;
    if(read_profile_string(audio_setting_section,ktv_audio_output_index_key,buf,MAX_SIZE,"",file)) {
        config.audioConfigKTVIndex=atoi(buf);
        if(config.audioConfigKTVIndex<0||config.audioConfigKTVIndex>=config.audioConfigInfo.size())
            logger::inst()->log(TAG_ERROR,"%s Error.\n","audioConfigKTVIndex");
        else
            logger::inst()->log(TAG_INFO,"KTVAudioOutput set to:%s\n",config.audioConfigInfo[config.audioConfigKTVIndex].second.c_str());
    }
}
void SaveAudioOutputDevice(intf_thread_t* p_intf,RC_CONFIG& config) {
    if(!p_intf) {
        logger::inst()->log(TAG_INFO,"%s\n","InputThread is NULL ::SaveAudioOutputDevice.");
        return;
    }
    config.audioConfigInfo.clear();
    vlc_object_t* p_aout=VLC_OBJECT(p_intf);
    char temp[MAX_SIZE];
    memset(temp,0,MAX_SIZE);
    getAudioOutputList(p_aout,temp);
    vector<string> aoutlist;
    char* psz=strdup(temp);
    parseList(psz,aoutlist);
    free(psz);
    int cnt=0;
    for(int i=0;i<aoutlist.size();i++) {
        memset(temp,0,MAX_SIZE);
        char* device_config_name;
        getCurrentAudioOutputDeviceList(p_aout,const_cast<char*>(aoutlist[i].c_str()),temp);
        /*we don't want names like aout_directx*/
        char* delimeter=strstr(aoutlist[i].c_str(),"_");
        char* aout=strdup(delimeter?delimeter+1:aoutlist[i].c_str());
        if(strlen(temp)) {
            vector<string> aoutdevicelist;
            psz=strdup(temp);
            parseList(psz,aoutdevicelist);
            asprintf(&device_config_name,"%s-audio-device",aout);
            for(int j=0;j<aoutdevicelist.size();j++) {
                config.audioConfigInfo.push_back(std::make_pair(aout,aoutdevicelist[j].c_str()));
                logger::inst()->log("found audio output device:[%s]\n",config.audioConfigInfo[cnt++].second.c_str());
            }
            free(device_config_name);
        }
        else {
            config.audioConfigInfo.push_back(std::make_pair("aout",aoutlist[i].c_str()));
            logger::inst()->log("found audio output:[%s]\n",config.audioConfigInfo[cnt++].first.c_str());
        }
        free(aout);
    }
}
void SaveAudioOutputDevice(intf_thread_t* p_intf,RC_CONFIG& config,const char* file) {
    SaveAudioOutputDevice(p_intf,config);
    FILE* f=fopen(file,"w");
    fclose(f);
    char* audio_information_section="AudioOutputInformation";
    for(int i=0;i<config.audioConfigInfo.size();i++) {
        char* key;
        char* value;
        if(asprintf(&key,"%d",i)==-1) {
            logger::inst()->log(TAG_INFO,"Error In Saving Audiooutput Information for %s\n",config.audioConfigInfo[i].first.c_str());
            continue;
        }
        if(asprintf(&value,"[%s][%s]",config.audioConfigInfo[i].first.c_str(),config.audioConfigInfo[i].second.c_str())==-1) {
            logger::inst()->log(TAG_INFO,"Error In Saving Audiooutput Information for %s\n",config.audioConfigInfo[i].first.c_str());
            continue;
        }
        write_profile_string(audio_information_section,key,value,file);
        free(key);
        free(value);
    }
}
char* CheckMessage(char* src) {
    /*check utf8 encoding*/
    if(IsUTF8(src)) 
        return src;
    logger::inst()->log(TAG_INFO,"[command:%s][is not UTF8]\n",src);
    char* utf8=FromWide((wchar_t*)src);
    char* ensureUtf8=EnsureUTF8(strdup(src));
    if(utf8) {
        logger::inst()->log(TAG_INFO,"[::FromWide:%s]\n",utf8);
    }
    if(ensureUtf8) {
        logger::inst()->log(TAG_INFO,"[::ensureUTF8:%s]\n",ensureUtf8);
    }
    return EnsureUTF8(strdup(src));
}
void RCServer::run(void *p) {
    RCServer* pServer = reinterpret_cast<RCServer*>(p);
    SOCKADDR_IN addrClient = { 0 };
    char msgRcv[MAX_SIZE] = { 0 };
    char msgSent[MAX_SIZE] = { 0 };
    int msgSize = -1;
    rc_para* pPara = NULL;
    int result;
    int id;
    rc_value_t val = { 0 };
    while (pServer->isSocketOpen()) {
        logger::inst()->log(TAG_DEBUG,"%s\n","waiting....");
        result = VLC_EGENERIC;
        memset(msgRcv, 0, MAX_SIZE);
        memset(msgSent, 0, MAX_SIZE);
        pServer->getPacket(*(sockaddr*)&addrClient, msgRcv, msgSize, MAX_SIZE);
        playlist_t* pPlayList = pl_Get(pServer->getIntf());
        val.f_float = 0.0;
        val.psz_string = NULL;
        val.b_bool = false;
        input_thread_t* p_input = playlist_CurrentInput(pPlayList);
        if (parseMsg(CheckMessage(msgRcv), val))
            result = Input(pServer->getIntf(), p_input, msgRcv, val, msgSent);
        else {
            /*return "invalid command" if using setCommand without a parameter*/
            ENCODE_MSG_WITH_RETURN(msgSent,"%s","invalid command");
        }
        /*all of the strings,including both english and chinese,haved been encoded to UTF-8 by vlc.@yulw,15-11.20*/
        pServer->sendPacket(*(sockaddr*)&addrClient, msgSent,strlen(msgSent)+1,MAX_LEN);

    }
    logger::inst()->log(TAG_INFO,"%s\n","rcserver exited.");

}

